# WAVS

Repository: https://github.com/Lay3rLabs/wavs-foundry-template
README with commands: https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/README.md

> A framework for building decentralized services that perform off-chain computation with on-chain verification. WAVS (WASI Autonomous Verifiable Services) enables developers to create high-performance AVS services using WASM/WASI for computation and EigenLayer for security.

WAVS streamlines AVS development by providing:
- WASM/WASI runtime for near-native performance
- EigenLayer integration for security via restaking
- Dynamic deployment and updates
- Cross-chain compatibility

## Core Documentation

- [Overview](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/overview.mdx): Core concepts and architecture
- [Technical Details](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/how-it-works.mdx): In-depth platform mechanics
- [Design Guidelines](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/design.mdx): Best practices and AVS design patterns
- [Benefits](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/benefits.mdx): Platform advantages

## Service Components

### 1. Trigger Contract
- [Example Contract](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/src/contracts/WavsTrigger.sol): On-chain event trigger
- [Contract Guide](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/how-it-works.mdx#triggers): Implementing triggers

### 2. WASI Component
- [Example Component](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/components/eth-price-oracle/src/lib.rs): Off-chain computation in Rust
- [Component Guide](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/how-it-works.mdx#service-components): Building components

### 3. Submission Contract
- [Example Handler](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/src/contracts/WavsSubmit.sol): Result verification
- [Handler Guide](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/how-it-works.mdx#submission): Implementing handlers

## Tutorial

- [1. Overview](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/tutorial/1-overview.mdx): Introduction and concepts
- [2. Setup](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/tutorial/2-setup.mdx): Environment configuration  
- [3. Project](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/tutorial/3-project.mdx): Project structure
- [4. Component](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/tutorial/4-component.mdx): Building components
- [5. Build](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/tutorial/5-build.mdx): Testing services
- [6. Deploy](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/tutorial/6-run-service.mdx): Service deployment
- [7. Oracle](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/docs/tutorial/7-prediction.mdx): Example oracle service

## System Requirements

### Core
- Docker & Docker Compose
- Make & JQ
- Node.js v21+

### Rust Setup
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup toolchain install stable
rustup target add wasm32-wasip2
```

### Cargo Components
```bash
cargo install cargo-binstall
cargo binstall cargo-component warg-cli wkg --locked
wkg config --default-registry wa.dev
```

## Essential Documentation

- [README.md](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/README.md): Main documentation with all make commands
- [Makefile](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/Makefile): Full build automation script with variables.

## Quick Start
Run through the template oracle example. All commands found in https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/README.md

1. Create project:
```bash
forge init --template Lay3rLabs/wavs-foundry-template my-service --branch v0.3.0
cd my-service
make setup
cp .env.example .env
```

2. Build and test:
```bash
forge build
forge test
make wasi-build
COIN_MARKET_CAP_ID=1 make wasi-exec  # Test component directly
```

3. Deploy:
```bash
# This must remain running in your terminal. Use another terminal to run other commands.
make start-all  # Start local env
# Open a new terminal
export SERVICE_MANAGER_ADDR=`make get-eigen-service-manager-from-deploy`
forge script ./script/Deploy.s.sol ${SERVICE_MANAGER_ADDR} --sig "run(string)" --rpc-url http://localhost:8545 --broadcast
TRIGGER_EVENT="NewTrigger(bytes)" make deploy-service
```

4. Trigger the service:
```bash
export COIN_MARKET_CAP_ID=1
export SERVICE_TRIGGER_ADDR=`make get-trigger-from-deploy`
forge script ./script/Trigger.s.sol ${SERVICE_TRIGGER_ADDR} ${COIN_MARKET_CAP_ID} --sig "run(string,string)" --rpc-url http://localhost:8545 --broadcast -v 4
# Get the latest TriggerId and show the result via `script/ShowResult.s.sol`
make show-result
```
## Common Issues

### Mac ARM (M1/M2) Setup
- Install Rosetta: `softwareupdate --install-rosetta`
- Enable Rosetta in Docker Desktop: Settings -> General -> "Use Rosetta for x86_64/amd64 emulation"
- Configure networking:
  - Enable host networking in Docker Desktop, or
  - Install network connect: `brew install chipmk/tap/docker-mac-net-connect`

### Component Building
- If error "no registry configured": Run `wkg config --default-registry wa.dev`
- For consensus, ensure deterministic execution and data sources
- Test locally with `make wasi-exec` before deployment

## Component Development

### Requirements
- Deterministic execution for consensus
- Immutable/deterministic data sources
- No component-local state
- Proper error handling

### Project Structure
```
my-service/
├── components/          # WASM service implementations
│   └── my-component/    # Your Rust component(s)
├── src/
│   ├── contracts/      # Solidity contracts
│   └── interfaces/     # Contract interfaces
├── .env               # Environment configuration
└── Makefile          # Build automation
```

### Trigger Handling

The trigger contract emits a `NewTrigger` event with encoded trigger information. When a WAVS component receives this trigger, it uses the `decode_event_log_data!` macro from the `wavs-wasi-chain` crate to decode the event data for processing.

Each trigger has a unique ID that links it to its data. The component processes the trigger data and returns results. Results are submitted back to the blockchain via the submission contract.

### Network Requests

Components can make network requests to external APIs using the `wavs-wasi-chain` crate. Here's an example of making an HTTP GET request:

```rust
use wavs_wasi_chain::http::{fetch_json, http_request_get};
use wstd::http::HeaderValue;

async fn make_request() -> Result<(), String> {
    let url = "https://api.example.com/data";
    let mut req = http_request_get(url).map_err(|e| e.to_string())?;
    
    // Set headers
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    
    // Make request and parse JSON response
    let json: Response = fetch_json(req).await.map_err(|e| e.to_string())?;
    Ok(())
}
```

### Logging

When developing your own WASI component, it's helpful to use logging methods in your code. Components write all their standard output and errors (`stdout` or `stderr`) to the host machine.

For development:
```rust
println!("Debug info: {:?}", data);  // Writes to stdout
```

For production:
```rust
use crate::bindings::wavs::worker::layer_types::LogLevel;
host::log(LogLevel::Info, "Production log message");
```

The production logging includes additional context like `ServiceID`, `WorkflowID`, and component `Digest`.

### Component Building Process

1. Place your Rust component in a subdirectory of `components/`
2. Each component must implement the `Guest` trait and use `export!(Component)`
3. Running `make wasi-build`:
   - Generates WASI bindings for each component
   - Compiles all components to WASM using `cargo component build --release`
   - Formats code with `cargo fmt`
   - Copies `.wasm` files to `compiled/` directory
4. Test components with `COMPONENT_FILENAME=your_component.wasm make wasi-exec`
5. Deploy using `TRIGGER_EVENT="YourEvent(bytes)" make deploy-service`

### Essential Dependencies

The following dependencies are required in `Cargo.toml` for building components:

```toml
[dependencies]
wit-bindgen-rt = {workspace = true}    # Required for WASI bindings and Guest trait
wavs-wasi-chain = { workspace = true }  # Required for core WAVS functionality
```

Optional dependencies (add as needed):
```toml
[dependencies]
serde = { workspace = true }            # For serialization (if working with JSON)
serde_json = { workspace = true }       # For JSON handling
alloy-sol-macro = { workspace = true }  # For Ethereum contract interactions
wstd = { workspace = true }             # For WASI standard library features
alloy-sol-types = { workspace = true }  # For Ethereum ABI handling
anyhow = { workspace = true }           # For enhanced error handling
```

### Component Structure

A basic component has three main parts:

1. Decoding incoming trigger data
2. Processing the data (your custom logic)
3. Encoding and returning the result

Here's a minimal example:

```rust
pub mod bindings;
use crate::bindings::{export, Guest, TriggerAction};
struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<Vec<u8>>, String> {
        let (trigger_id, req, dest) = decode_trigger_event(action.data)?;
        let result = process_data(req)?;
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &result)),
            Destination::CliOutput => Some(result),
        };
        Ok(output)
    }
}
```

### Testing

To test your components locally:

1. Build the component:
```bash
make build
```

2. Test with input:
```bash
make wasi-exec
```

The `wasi-exec` command allows you to simulate triggers using the `--input` flag. You can view the component's logs in stdout/stderr to debug its execution.

### Important Notes

1. The `run` function is the entry point for processing triggers. It receives the trigger data, decodes it, processes it according to your component's logic, and returns the results.

2. Results can be sent back to Ethereum (when triggered by a contract event) or returned as CLI output (when triggered manually during testing).

3. Error handling is done through the `Result` type.

4. Bindings are automatically generated for any files in the `/components` and `/src` directories when the `make build` command is run.

5. The `Destination` enum determines where the output should be sent:
   - `Ethereum`: When triggered by a contract event
   - `CliOutput`: When triggered manually during testing

## Configuration

Key settings in `.env` and `Makefile`:

```bash
# Core Settings (.env)
WAVS_DATA=.docker              # Data directory
WAVS_LOG_LEVEL=info           # Logging level
RPC_URL=http://localhost:8545 # Ethereum node

# Component Settings (Makefile)
COMPONENT_FILENAME=eth_price_oracle.wasm  # Your component
TRIGGER_EVENT="NewTrigger(bytes)"        # Event signature

# Service Settings (both)
SERVICE_CONFIG='{                        # Component config
  "fuel_limit": 100000000,
  "max_gas": 5000000,
  "workflow_id": "default"
}'
```

See full options in:
- [.env.example](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/.env.example)
- [Makefile](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/Makefile)

## Custom Triggers

To implement a custom trigger, modify these files:

1. [WavsTrigger.sol](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/src/contracts/WavsTrigger.sol): Define trigger event and data structure
2. [Makefile](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/Makefile): Update `wasi-exec` test input
3. `components/your-component/src/trigger.rs`: Implement `decode_trigger_event` for your data format
4. `components/your-component/src/lib.rs`: Process trigger data in `run` function
5. [Trigger.s.sol](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/script/Trigger.s.sol): Update deployment script

Flow: Contract emits event → Component decodes data → Process → Encode result → Submit

Example implementation in [eth-price-oracle](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/components/eth-price-oracle/src/lib.rs)

## Example Code

From [WavsTrigger.sol](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/src/contracts/WavsTrigger.sol):
```solidity
// Trigger Contract
contract WavsTrigger {
    event NewTrigger(bytes data);
    function requestData(bytes calldata _input) external {
        emit NewTrigger(_input);
    }
}
```

From [WavsSubmit.sol](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/src/contracts/WavsSubmit.sol):
```solidity
// Submission Contract
contract SimpleSubmit is IWavsServiceHandler {
    function handleSignedData(bytes calldata _data, bytes calldata _signature) external {
        _serviceManager.validate(_data, _signature);
        (bytes32 triggerId, bytes memory result) = decode_result(_data);
        _results[triggerId] = result;
    }
}
```

From [eth-price-oracle/src/lib.rs](https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/v0.3.0/components/eth-price-oracle/src/lib.rs):
```rust
// WASI Component
impl Guest for Component {
    fn run(action: TriggerAction) -> Result<Option<Vec<u8>>, String> {
        let (trigger_id, input) = decode_trigger_event(action.data)?;
        let result = compute_result(input)?;
        Ok(Some(encode_result(trigger_id, result)))
    }
}
```

# WAVS Component Development Guide

## Core Dependencies
```toml
[dependencies]
wit-bindgen-rt = {workspace = true}    # WASI bindings and Guest trait
wavs-wasi-chain = { workspace = true }  # Core WAVS functionality
```

## Component Structure
```rust
pub mod bindings;
use crate::bindings::{export, Guest, TriggerAction};
struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<Vec<u8>>, String> {
        let (trigger_id, req, dest) = decode_trigger_event(action.data)?;
        let result = process_data(req)?;
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &result)),
            Destination::CliOutput => Some(result),
        };
        Ok(output)
    }
}
```

## Trigger Handling
- Trigger contract emits `NewTrigger` event with encoded data
- Component uses `decode_event_log_data!` macro to decode event data
- Each trigger has unique ID linking to its data
- Results submitted back via submission contract

## Network Requests
```rust
use wavs_wasi_chain::http::{fetch_json, http_request_get};
use wstd::http::HeaderValue;

async fn make_request() -> Result<(), String> {
    let url = "https://api.example.com/data";
    let mut req = http_request_get(url).map_err(|e| e.to_string())?;
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    let json: Response = fetch_json(req).await.map_err(|e| e.to_string())?;
    Ok(())
}
```

## Logging
Development:
```rust
println!("Debug info: {:?}", data);
```

Production:
```rust
use crate::bindings::wavs::worker::layer_types::LogLevel;
host::log(LogLevel::Info, "Production log message");
```

## Build Process
1. Place component in `components/` subdirectory
2. Implement `Guest` trait with `export!(Component)`
3. `make wasi-build`:
   - Generates WASI bindings
   - Compiles to WASM
   - Copies to `compiled/`
4. Test: `COMPONENT_FILENAME=component.wasm make wasi-exec`
5. Deploy: `TRIGGER_EVENT="Event(bytes)" make deploy-service`

## Key Points
1. `run` function: Entry point for trigger processing
2. Results: Can return to Ethereum or CLI output
3. Error handling: Uses `Result` type
4. Bindings: Auto-generated for `/components` and `/src`
5. `Destination` enum: Controls output destination

## Configuration
```bash
WAVS_DATA=.docker
WAVS_LOG_LEVEL=info
RPC_URL=http://localhost:8545
COMPONENT_FILENAME=component.wasm
TRIGGER_EVENT="Event(bytes)"
```

## Example Contracts
```solidity
// Trigger
contract WavsTrigger {
    event NewTrigger(bytes data);
    function requestData(bytes calldata _input) external {
        emit NewTrigger(_input);
    }
}

// Submission
contract SimpleSubmit is IWavsServiceHandler {
    function handleSignedData(bytes calldata _data, bytes calldata _signature) external {
        _serviceManager.validate(_data, _signature);
        (bytes32 triggerId, bytes memory result) = decode_result(_data);
        _results[triggerId] = result;
    }
}
```

## Example Components

### Prediction Market Oracle
```rust
#[allow(warnings)]
mod bindings;
use bindings::{export, Guest, TriggerAction};
mod trigger;
use serde::{Deserialize, Serialize};
use trigger::{decode_trigger_event, encode_trigger_output};
use wavs_wasi_chain::http::{fetch_json, http_request_get};
use wstd::{http::HeaderValue, runtime::block_on};

struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        // Decode trigger data containing market parameters
        let (trigger_info, data) = decode_trigger_event(action.data)?;

        // Fetch current Bitcoin price from CoinMarketCap
        let bitcoin_price = block_on(get_price_feed(1))?;

        // Market resolution logic: YES if Bitcoin price > $1
        let result = bitcoin_price > 1.0;

        // Encode result with market parameters for on-chain submission
        Ok(encode_trigger_output(
            trigger_info.triggerId,
            data.lmsrMarketMaker,
            data.conditionalTokens,
            result,
        ))
    }
}

// Fetches price data from CoinMarketCap API
async fn get_price_feed(id: u64) -> Result<f64, String> {
    let url = format!(
        "https://api.coinmarketcap.com/data-api/v3/cryptocurrency/detail?id={}&range=1h",
        id
    );

    // Add required headers for API request
    let current_time = std::time::SystemTime::now().elapsed().unwrap().as_secs();
    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    req.headers_mut()
        .insert("User-Agent", HeaderValue::from_static("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36"));
    req.headers_mut().insert(
        "Cookie",
        HeaderValue::from_str(&format!("myrandom_cookie={}", current_time)).unwrap(),
    );

    // Parse JSON response into structured data
    let json: Root = fetch_json(req).await.map_err(|e| e.to_string())?;
    Ok(json.data.statistics.price)
}

// API response data structures
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Root {
    pub data: Data,
    pub status: Status,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Data {
    pub id: f64,
    pub name: String,
    pub symbol: String,
    pub statistics: Statistics,
    pub description: String,
    pub category: String,
    pub slug: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Statistics {
    pub price: f64,
    #[serde(rename = "totalSupply")]
    pub total_supply: f64,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Status {
    pub timestamp: String,
    pub error_code: String,
    pub error_message: String,
    pub elapsed: String,
    pub credit_count: f64,
}
```

Key features:
- Fetches Bitcoin price from CoinMarketCap API
- Resolves market based on price threshold
- Uses LMSR market maker and conditional tokens for settlement
- Handles API authentication and rate limiting
- Structured response parsing with Serde

### Safe-Guard Component
```rust
#[allow(warnings)]
mod bindings;
use alloy_sol_types::{sol, SolValue};  // For Solidity type definitions and ABI encoding
use bindings::{
    export,
    wavs::worker::layer_types::{TriggerData, TriggerDataEthContractEvent},
    Guest, TriggerAction,
};
use wavs_wasi_chain::decode_event_log_data;  // For decoding Ethereum event logs

// Define Solidity event and struct types using alloy-sol-types
sol! {
    #[derive(Debug)]
    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);

    #[derive(Debug)]
    struct ValidationPayload {
        bytes32 approvedHash;
        bool approved;
    }
}

struct Component;

impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        match trigger_action.data {
            // Handle Ethereum contract events
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {
                // Decode ApproveHash event from log data
                let ApproveHash { approvedHash, .. } = decode_event_log_data!(log)
                    .map_err(|e| format!("Failed to decode event log data: {}", e))?;

                // Create and encode validation payload
                Ok(ValidationPayload { approvedHash, approved: true }.abi_encode())
            }
            _ => Err("Unsupported trigger data".to_string()),
        }
    }
}

export!(Component with_types_in bindings);
```

Key features:
- Decodes Ethereum contract events using `decode_event_log_data!` macro
- Uses `alloy-sol-types` for Solidity type definitions and ABI encoding
- Implements validation logic for transaction approval
- Returns encoded validation payload for on-chain processing
- Handles only Ethereum contract events, rejects other trigger types

### DAO Agent Component
```rust
mod bindings;
mod context;
mod integration_tests;
mod models;
mod ollama;

use alloy_primitives::{Address, Bytes, U256};  // For Ethereum primitive types
use alloy_sol_types::{sol, SolCall, SolType, SolValue};  // For Solidity type definitions
use anyhow::Result;
use bindings::{
    export,
    wavs::worker::layer_types::{TriggerData, TriggerDataEthContractEvent},
    Guest, TriggerAction,
};
use models::{DaoContext, SafeTransaction};  // Custom types for DAO context and transactions
use ollama::OllamaChatResponse;  // For Ollama API responses
use serde_json::json;
use std::str::FromStr;
use wstd::{
    http::{Client, IntoBody, Request},
    io::AsyncRead,
    runtime::block_on,
};

// Define Solidity interface for ERC20 token interactions
sol! {
    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
    }

    #[derive(Debug)]
    struct TransactionPayload {
        address to;
        uint256 value;
        bytes data;
    }
}

struct Component;

impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        match trigger_action.data {
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {
                // Decode the prompt from the event data
                let decoded = alloy_sol_types::sol_data::String::abi_decode(&log.data, false)
                    .map_err(|e| format!("Failed to decode ABI string: {}", e))?;

                let prompt = decoded.to_string();

                return block_on(async move {
                    // Query Ollama for transaction decision
                    let response = query_ollama(&prompt).await?;

                    println!("Response: {}", response);

                    // Extract tool call or return no-op if none found
                    let tool_call = match response
                        .split("<tool_call>")
                        .nth(1)
                        .and_then(|s| s.split("</tool_call>").next())
                    {
                        Some(call) => call,
                        None => {
                            // Return no-op transaction if no tool call found
                            let no_op = create_no_op_transaction("No action needed");
                            let payload = create_payload_from_safe_tx(&no_op)?;
                            return Ok(payload.abi_encode().to_vec());
                        }
                    };

                    // Parse and validate transaction
                    let transaction: SafeTransaction = serde_json::from_str(tool_call)
                        .map_err(|e| format!("Failed to parse transaction: {}", e))?;

                    // Validate destination address
                    if transaction.to.is_empty()
                        || transaction.to == "0x"
                        || transaction.to.len() < 42
                    {
                        let no_op = create_no_op_transaction("Invalid or missing destination address");
                        let payload = create_payload_from_safe_tx(&no_op)?;
                        return Ok(payload.abi_encode().to_vec());
                    }

                    // Create and encode transaction payload
                    let payload = create_payload_from_safe_tx(&transaction)?;
                    println!("Payload: {:?}", payload);
                    Ok(payload.abi_encode().to_vec())
                });
            }
            _ => Err("Unsupported trigger data".to_string()),
        }
    }
}

// Helper function to create no-op transactions
fn create_no_op_transaction(reason: &str) -> SafeTransaction {
    SafeTransaction {
        to: "0x0000000000000000000000000000000000000000".to_string(),
        value: "0".to_string(),
        contract_call: None,
        data: "0x".to_string(),
        description: format!("No action taken: {}", reason),
    }
}

// Convert SafeTransaction to TransactionPayload
fn create_payload_from_safe_tx(tx: &SafeTransaction) -> Result<TransactionPayload, String> {
    // Parse and validate address
    let to: Address = tx.to.parse().map_err(|e| format!("Invalid address: {}", e))?;
    let value = U256::from_str(&tx.value).map_err(|e| format!("Invalid value: {}", e))?;

    // Handle contract calls (e.g., ERC20 transfers)
    let data = if let Some(contract_call) = &tx.contract_call {
        match contract_call.function.as_str() {
            "transfer" => {
                let recipient = contract_call.args[0]
                    .as_str()
                    .ok_or("Missing recipient")?
                    .parse::<Address>()
                    .map_err(|e| format!("Invalid recipient address: {}", e))?;
                let amount = U256::from_str(contract_call.args[1].as_str().ok_or("Missing amount")?)
                    .map_err(|e| format!("Invalid amount: {}", e))?;

                let call = IERC20::transferCall { recipient, amount };
                Bytes::from(call.abi_encode())
            }
            _ => Bytes::default(),
        }
    } else {
        Bytes::default()
    };

    Ok(TransactionPayload { to, value, data })
}

// Query Ollama API for transaction decisions
async fn query_ollama(prompt: &str) -> Result<String, String> {
    let context = DaoContext::default();

    // Format contract information for system prompt
    let contract_descriptions = context
        .contracts
        .iter()
        .map(|contract| {
            format!(
                "Contract: {}\nAddress: {}\nABI:\n{}",
                contract.name, contract.address, contract.abi
            )
        })
        .collect::<Vec<_>>()
        .join("\n\n");

    // Construct system prompt with DAO context and security rules
    let system_prompt = format!(
        r#"
        You are a function calling AI model with a list of smart contracts and their ABIs in <tools></tools> XML tags, a DAO agent 
        responsible for making and executing decisions through a Gnosis Safe Module.

        Current DAO Context:
        - Safe Address: {}
        - Current Balances:
        {}
        - Allowed Addresses: {}
        - DAO Mission: {}
        - Allowed Tokens: ONLY native ETH and USDC are supported. All other token requests should be rejected.

        Available Smart Contracts:
        <tools>
        {}
        </tools>

        REQUIRED JSON FIELDS - ALL MUST BE INCLUDED:
        1. "to": destination address
        2. "value": amount in wei
        3. "data": MUST be included and set to "0x" for simple transfers
        4. "description": explanation of the action
        5. "contract_call": (optional) only for token transfers

        STRICT JSON RULES:
        - NO comments in JSON
        - NO trailing commas
        - NO explanatory text inside JSON
        - ALL fields above must be present
        - The "data" field must ALWAYS be included
        - JSON must be strictly valid

        Examples:

        1. Simple ETH transfer:
        <tool_call>
        {{
            "to": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
            "value": "1000000000000000000",
            "data": "0x",
            "description": "Sending 1 ETH to specified address"
        }}
        </tool_call>

        2. USDC transfer:
        <tool_call>
        {{
            "to": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
            "value": "0",
            "data": "0x",
            "contract_call": {{
                "function": "transfer",
                "args": ["0x742d35Cc6634C0532925a3b844Bc454e4438f44e", "1000000"]
            }},
            "description": "Sending 1 USDC to specified address"
        }}
        </tool_call>

        3. No action needed:
        <tool_call>
        {{
            "to": "0x0000000000000000000000000000000000000000",
            "value": "0",
            "data": "0x",
            "description": "No action needed: [reason]"
        }}
        </tool_call>

        Security Guidelines:
        - Always verify addresses are in the allowed list or contract list
        - Include the contract_call field in the JSON if a contract call is needed
        - When making a smart contract call, ALWAYS use the contract address in the "to" field
        - If using an ERC20 token (such as USDC), ALWAYS use the contract address in the "to" field
        - Never approve transactions that would spend more than the current balance
        - Be extremely cautious with value transfers
        - Reject any suspicious or unclear requests
        - Don't allow transfers of amounts greater than 1 ETH
        - IMMEDIATELY REJECT any requests for tokens other than ETH or USDC with a no-op transaction
        - ALWAYS output JSON within <tool_call></tool_call> XML tags
        - ALWAYS end your response with JSON wrapped in <tool_call></tool_call> XML tags
        - NEVER wrap <tool_call></tool_call> with anything including markdown formatting
    "#,
        context.safe_address,
        context.format_balances(),
        context.allowed_addresses.join(", "),
        context.dao_description,
        contract_descriptions,
    );

    // Make request to Ollama API
    let req = Request::post("http://localhost:11434/api/chat")
        .body(
            serde_json::to_vec(&json!({
                "model": "llama3.1",
                "messages": [{
                    "role": "system",
                    "content": system_prompt
                }, {
                    "role": "user",
                    "content": prompt
                }],
                "options": {
                    "temperature": 0.0,        // Deterministic output
                    "top_k": 1,               // Strict selection
                    "top_p": 0.1,             // Narrow sampling
                    "min_p": 0.0,             // Disabled
                    "num_ctx": 4096,          // Context window
                    "num_predict": 500,       // Max tokens
                    "seed": 42,               // Fixed seed
                },
                "stream": false
            }))
            .unwrap()
            .into_body(),
        )
        .unwrap();

    // Send request and handle response
    let mut res = Client::new().send(req).await.map_err(|e| e.to_string())?;

    if res.status() != 200 {
        return Err(format!("Ollama API error: status {}", res.status()));
    }

    let mut body_buf = Vec::new();
    res.body_mut().read_to_end(&mut body_buf).await.unwrap();

    let resp = String::from_utf8_lossy(&body_buf);
    let resp = serde_json::from_str::<OllamaChatResponse>(format!(r#"{}"#, resp).as_str());

    match resp {
        Ok(OllamaChatResponse::Success(success)) => Ok(success.message.content),
        Ok(OllamaChatResponse::Error { error }) => Err(error),
        Err(e) => Err(format!("Failed to parse response: {}", e)),
    }
}

export!(Component with_types_in bindings);
```

Key features:
- Uses Ollama API for AI-powered transaction decisions
- Implements strict security rules for transaction validation
- Supports ETH and USDC transfers with proper contract calls
- Handles no-op transactions for rejected requests
- Uses deterministic AI parameters for consistent decisions
- Validates addresses and amounts before execution
- Provides detailed transaction descriptions
- Implements proper error handling and logging

### ETH-Cosmos Bridge Component
```rust
use alloy_sol_macro::sol;  // For Solidity type definitions
use alloy_sol_types::SolValue;  // For ABI encoding
use bindings::{
    export,
    wavs::worker::layer_types::{
        TriggerData, TriggerDataCosmosContractEvent, TriggerDataEthContractEvent,
    },
    Guest, TriggerAction,
};
use trigger_contract::event::NewDepositEvent;  // For Cosmos deposit event handling

mod bindings;

struct Component;

impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        match trigger_action.data {
            // Handle Ethereum contract events (placeholder for future implementation)
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { .. }) => {}
            
            // Handle Cosmos contract events
            TriggerData::CosmosContractEvent(TriggerDataCosmosContractEvent { event, .. }) => {
                // Check for deposit events from Cosmos chain
                if event.ty.as_str() == NewDepositEvent::KEY
                    || event.ty.as_str() == format!("wasm-{}", NewDepositEvent::KEY)
                {
                    // Extract event attributes
                    let mut amount = None;
                    let mut sender = None;
                    let mut recipient = None;

                    // Parse event attributes
                    for (key, value) in event.attributes.into_iter() {
                        match key.as_str() {
                            "amount" => amount = Some(value),
                            "sender" => sender = Some(value),
                            "recipient" => recipient = Some(value),
                            _ => {}
                        }
                    }

                    // Process deposit event if all required fields are present
                    match (amount, sender, recipient) {
                        (Some(amount), Some(sender), Some(recipient)) => {
                            let response = BridgeDeposit {
                                amount: amount
                                    .parse()
                                    .map_err(|e| format!("Failed to parse amount: {}", e))?,
                                sender,
                                recipient: alloy_primitives::Address::parse_checksummed(
                                    recipient, None,
                                )
                                .map_err(|e| format!("Failed to parse recipient: {}", e))?,
                            };

                            return Ok(response.abi_encode());
                        }
                        _ => {}
                    }
                }
            }
            // Handle raw trigger data (placeholder for future implementation)
            TriggerData::Raw(_) => {}
        };

        Ok(Vec::new())
    }
}

// Import Solidity types from contract
sol!("../contracts/solidity/Types.sol",);

export!(Component with_types_in bindings);
```

Key features:
- Handles cross-chain bridge events between Ethereum and Cosmos
- Processes Cosmos deposit events with amount, sender, and recipient
- Validates and parses Ethereum addresses
- Supports both standard and WASM event types
- Returns encoded bridge deposit data for on-chain processing
- Implements proper error handling for parsing failures
- Uses Solidity type definitions for consistent data structures
- Extensible for future ETH-to-Cosmos event handling

### Telegram Bot Component
```rust
mod bindings;
mod telegram;  // Module for Telegram API interactions

use alloy_sol_types::SolValue;  // For ABI encoding
use bindings::{
    export,
    wavs::worker::layer_types::{TriggerData, TriggerDataEthContractEvent},
    Guest, TriggerAction,
};
use serde_json::json;  // For JSON handling
use std::str::FromStr;
use wstd::{
    http::{Client, IntoBody, Request},
    io::AsyncRead,
    runtime::block_on,
};

struct Component;

impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        match trigger_action.data {
            // Handle Ethereum contract events
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {
                // Decode the message from the event data
                let decoded = alloy_sol_types::sol_data::String::abi_decode(&log.data, false)
                    .map_err(|e| format!("Failed to decode ABI string: {}", e))?;

                let message = decoded.to_string();

                return block_on(async move {
                    // Send message to Telegram
                    let response = send_telegram_message(&message).await?;

                    println!("Telegram response: {}", response);

                    // Return success response
                    Ok(Vec::new())
                });
            }
            _ => Err("Unsupported trigger data".to_string()),
        }
    }
}

// Send message to Telegram API
async fn send_telegram_message(message: &str) -> Result<String, String> {
    // Get bot token from environment
    let bot_token = std::env::var("TELEGRAM_BOT_TOKEN")
        .map_err(|e| format!("Failed to get TELEGRAM_BOT_TOKEN: {}", e))?;

    // Get chat ID from environment
    let chat_id = std::env::var("TELEGRAM_CHAT_ID")
        .map_err(|e| format!("Failed to get TELEGRAM_CHAT_ID: {}", e))?;

    // Construct Telegram API URL
    let url = format!(
        "https://api.telegram.org/bot{}/sendMessage",
        bot_token
    );

    // Create request body
    let body = json!({
        "chat_id": chat_id,
        "text": message,
        "parse_mode": "HTML"
    });

    // Create HTTP request
    let req = Request::post(&url)
        .body(
            serde_json::to_vec(&body)
                .unwrap()
                .into_body(),
        )
        .unwrap();

    // Send request
    let mut res = Client::new().send(req).await.map_err(|e| e.to_string())?;

    if res.status() != 200 {
        return Err(format!("Telegram API error: status {}", res.status()));
    }

    // Read response body
    let mut body_buf = Vec::new();
    res.body_mut().read_to_end(&mut body_buf).await.unwrap();

    // Parse response
    let resp = String::from_utf8_lossy(&body_buf);
    Ok(resp.to_string())
}

export!(Component with_types_in bindings);
```

Key features:
- Handles Ethereum contract events for message triggers
- Sends messages to Telegram using Bot API
- Uses environment variables for bot configuration
- Supports HTML formatting in messages
- Implements proper error handling
- Uses async/await for API requests
- Returns empty vector on success (no on-chain data needed)
- Logs API responses for debugging

### Common Data Structures and Interfaces

```rust
// Trigger data structure used across components
pub struct TriggerData {
    pub trigger_id: [u8; 32],
    pub data: Vec<u8>,
    pub destination: Destination,
}

// Market resolution interface
sol! {
    interface IMarketResolver {
        function resolveMarket(bytes32 marketId, bool outcome) external;
    }
}

// Bridge deposit structure
sol! {
    struct BridgeDeposit {
        uint256 amount;
        string sender;
        address recipient;
    }
}

// Safe transaction interface
sol! {
    struct SafeTransaction {
        address to;
        uint256 value;
        bytes data;
        string description;
        ContractCall contract_call;
    }

    struct ContractCall {
        string function;
        string[] args;
    }
}

// Telegram message structure
#[derive(Serialize, Deserialize)]
pub struct TelegramMessage {
    pub chat_id: String,
    pub text: String,
    pub parse_mode: Option<String>,
}

// DAO context structure
#[derive(Default)]
pub struct DaoContext {
    pub safe_address: String,
    pub balances: HashMap<String, String>,
    pub allowed_addresses: Vec<String>,
    pub dao_description: String,
    pub contracts: Vec<ContractInfo>,
}

#[derive(Default)]
pub struct ContractInfo {
    pub name: String,
    pub address: String,
    pub abi: String,
}
```

### Configuration Examples

```toml
# Example wavs.toml for component configuration
[service]
name = "example-service"
version = "0.1.0"

[chains]
ethereum = { rpc_url = "http://localhost:8545" }
cosmos = { rpc_url = "http://localhost:26657" }

[components]
prediction_market = { wasm = "prediction_market.wasm" }
safe_guard = { wasm = "safe_guard.wasm" }
dao_agent = { wasm = "dao_agent.wasm" }
bridge = { wasm = "bridge.wasm" }
telegram_bot = { wasm = "telegram_bot.wasm" }

[environment]
TELEGRAM_BOT_TOKEN = "${TELEGRAM_BOT_TOKEN}"
TELEGRAM_CHAT_ID = "${TELEGRAM_CHAT_ID}"
COINMARKETCAP_API_KEY = "${COINMARKETCAP_API_KEY}"
```

### WAVS Component Examples

### Common Patterns and Best Practices

1. **Standard Imports**
```rust
use bindings::{export, Guest, TriggerAction};
use wavs_wasi_chain::{decode_event_log_data, http};
use bindings::host::{self, LogLevel};
use wstd::runtime::block_on;

// For Ethereum interactions
use alloy_sol_types::{sol, SolValue};
use alloy_primitives::{Address, Bytes, U256};

// For external APIs
use serde::{Deserialize, Serialize};
use serde_json::json;
```

2. **Error Handling Pattern**
```rust
impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        // Always use descriptive error messages
        let data = decode_event_log_data!(trigger_action.data)
            .map_err(|e| format!("Failed to decode event data: {}", e))?;
            
        // Log important operations
        host::log(LogLevel::Info, &format!("Processing data: {:?}", data));
        
        // Return encoded results or empty vec for no-op
        Ok(data.abi_encode())
    }
}
```

3. **Configuration Structure**
```toml
[package]
name = "example-component"
version = "0.1.0"

[dependencies]
wit-bindgen-rt = { workspace = true }
wavs-wasi-chain = { workspace = true }
alloy-sol-types = { workspace = true }
serde = { workspace = true }
wstd = { workspace = true }

[package.metadata.component]
package = "wavs:example-component"
target = "wavs:worker/layer-trigger-world@0.3.0-alpha2"
```

### Example Components

1. **Price Oracle Component**
```rust
impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        // Decode market parameters
        let (trigger_id, params) = decode_trigger_event(trigger_action.data)?;
        
        // Fetch price with proper error handling
        let price = block_on(async {
            let response = http::fetch_json::<PriceResponse>(build_request()?).await?;
            Ok(response.price)
        })?;

        // Log operation
        host::log(LogLevel::Info, &format!("Price fetched: {}", price));

        // Return encoded result
        Ok(encode_oracle_result(trigger_id, price))
    }
}
```

2. **Safe-Guard Component**
```rust
impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        // Decode validation request
        let event = decode_event_log_data!(trigger_action.data)?;
        
        // Log validation
        host::log(LogLevel::Info, &format!("Validating hash: {:?}", event));

        // Return validation result
        Ok(ValidationPayload { 
            hash: event.hash,
            approved: true 
        }.abi_encode())
    }
}
```

3. **DAO Agent Component**
```rust
impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        // Decode proposal
        let proposal = decode_event_log_data!(trigger_action.data)?;
        
        // Get AI decision with proper error handling
        let decision = block_on(async {
            let response = query_ai(&proposal).await?;
            validate_decision(response)
        })?;

        // Log decision
        host::log(LogLevel::Info, &format!("AI decision: {:?}", decision));

        // Return encoded transaction
        Ok(encode_transaction(decision))
    }
}
```

4. **Bridge Component**
```rust
impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        match trigger_action.data {
            TriggerData::CosmosContractEvent(event) => {
                // Parse deposit with proper validation
                let deposit = parse_deposit(event)?;
                
                // Log bridge operation
                host::log(LogLevel::Info, &format!("Processing deposit: {:?}", deposit));

                // Return encoded bridge action
                Ok(encode_bridge_deposit(deposit))
            }
            _ => Ok(Vec::new()) // Standard no-op response
        }
    }
}
```

5. **Telegram Bot Component**
```rust
impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        // Decode message
        let message = decode_event_log_data!(trigger_action.data)?;
        
        // Send message with proper error handling
        block_on(async {
            let client = TelegramClient::new()?;
            
            // Log operation
            host::log(LogLevel::Info, "Sending Telegram message");
            
            client.send_message(message).await
        })?;

        Ok(Vec::new()) // Standard no-op response
    }
}
```

### Key Implementation Guidelines

1. **Error Handling**
- Always use `Result<Vec<u8>, String>` for consistency
- Provide descriptive error messages
- Use `map_err` for error conversion
- Log errors appropriately

2. **Logging**
- Use `host::log` for production logging
- Include operation context in log messages
- Use appropriate log levels

3. **Async Operations**
- Always wrap in `block_on`
- Proper error propagation
- Timeout handling

4. **Security**
- Validate all inputs
- Check permissions
- Sanitize external data

5. **Testing**
- Use `make wasi-exec` for local testing
- Test all error paths
- Verify deterministic behavior

### Configuration
```toml
[service]
name = "example-service"
version = "0.1.0"

[components]
prediction_market = { package = "wavs:prediction-market" }
safe_guard = { package = "wavs:safe-guard" }
dao_agent = { package = "wavs:dao-agent" }
bridge = { package = "wavs:bridge" }
telegram_bot = { package = "wavs:telegram-bot" }

[chains]
ethereum = { url = "${ETH_RPC_URL}" }
cosmos = { url = "${COSMOS_RPC_URL}" }

[environment]
# Add sensitive values to .env file
API_KEYS = "${API_KEYS}"
```
