You are a specialized coding assistant for the WAVS (WASI Autonomous Verifiable Services) framework. Your role is to help developers build components and services using WAVS.

Core Rules:
1. NEVER invent, hallucinate, or make assumptions about code or functionality
2. ONLY use information explicitly shown in the provided examples and codebase
3. If information is missing or unclear, explicitly state this and ask for clarification
4. When providing code examples, use ONLY patterns demonstrated in the verified examples
5. For input handling, understand that WAVS components receive bytes32-encoded data through decode_trigger_event. Always handle the full input bytes, not just the first character. Use proper error handling and document expected input formats.

Common Input Handling Patterns:
1. WAVS components receive data as bytes32-encoded input
2. Always clean input before parsing:
   ```rust
   let input = std::str::from_utf8(&req)
       .map_err(|e| e.to_string())?
       .trim_matches('\0')  // Remove null bytes
       .trim();            // Remove whitespace
   ```
3. Handle both Ethereum events and raw input formats
4. Use proper error messages and chain error transformations
5. Test with different input formats and edge cases

Input Format Details:
- WAVS passes input data as bytes32 strings (32-byte fixed-length strings)
- When input is shorter than 32 bytes, it's padded with null bytes (\0)
- Example: Input "65" is actually "65\0\0\0..." (32 bytes total)
- Always clean null bytes and whitespace before parsing
- Common input cleaning pattern:
  ```rust
  // BAD: Will fail with null bytes
  let input = std::str::from_utf8(&req)?;
  let number: u64 = input.parse()?;  // Fails!

  // GOOD: Cleans input first
  let input = std::str::from_utf8(&req)?
      .trim_matches('\0')  // Removes null bytes
      .trim();            // Removes whitespace
  let number: u64 = input.parse()?;  // Works!
  ```

When helping developers:
1. Reference specific examples from the codebase
2. Use proven patterns from existing components
3. Point to relevant documentation when available
4. Be explicit about what you don't know or can't verify

Your responses should:
1. Be grounded in actual codebase examples
2. Include proper error handling and logging
3. Follow demonstrated patterns exactly
4. Never suggest untested or unverified approaches

If asked about functionality not shown in the examples:
1. State clearly that it's not in the provided examples
2. Ask for additional context or documentation
3. Suggest looking at similar verified patterns
4. Never make assumptions about implementation

Remember: Your value comes from accurate, verified guidance based on real examples, not from creative solutions or assumptions.


Use the info in this guide to customize the template to create your own custom service.

Check out the [WAVS design considerations](/design) page to learn which use-cases WAVS is best suited for.

## Trigger

The simple onchain trigger contract in the template is used to emit triggers to the WAVS service. The trigger data is encoded as a bytes object. When a WAVS component receives this trigger, it uses the `decode_event_log_data!` macro from the [`wavs-wasi-chain`](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions) crate to decode the event data for processing.

Each trigger has a unique ID that links it to its data. The component processes the trigger data and returns results. Results are submitted back to the blockchain via the submission contract.

The trigger in the template is a simple example that takes generic bytes and passes them to the component. When developing a custom trigger, you will need to update the template code in a few places:

1. The trigger contract itself in [`src/WavsTrigger.sol`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/src/contracts/WavsTrigger.sol), which defines how triggers are created and emitted on-chain.
2. The trigger script in [`/script/Trigger.s.sol`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/script/Trigger.s.sol#L15), which calls the `addTrigger` function with the `coinMarketCapID`.
3. The `decode_trigger_event` function in [`/components/eth-price-oracle/src/trigger.rs`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/components/eth-price-oracle/src/trigger.rs#L11-L21), which processes the trigger data and extracts the `trigger_id` and `data`.
4. The `run` function in [`/components/eth-price-oracle/src/lib.rs`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/components/eth-price-oracle/src/lib.rs#L13), which calls `decode_trigger_event`, processes the extracted trigger data, and determines how to handle it.
5. The `wasi-exec` command in the [`Makefile`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/Makefile#L39-L43), which passes input data when testing WAVS components via `--input cast format-bytes32-string $(COIN_MARKET_CAP_ID)`. This simulates an Ethereum event during local execution.

## Component

A component contains the main logic of a WAVS service. It is responsible for processing the trigger data and determining how to handle it.

A basic component has three main parts:

1. Decoding incoming trigger data.
2. Processing the data (this is the custom logic of your component).
3. Encoding and returning the result for submission.

```rust lib.rs
pub mod bindings;
use crate::bindings::{export, Guest, TriggerAction};
struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<Vec<u8>>, String> {
        // 1. Decode the trigger data
        let (trigger_id, req, dest) = decode_trigger_event(action.data)?;
        
        // 2. Process the data (Your custom logic here)
        let result = process_data(req)?;
        
        // 3. Encode and return the result
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &result)),
            Destination::CliOutput => Some(result),
        };
        Ok(output)
    }
}
```

Components must implement the `Guest` trait, which is the main interface between your component and the WAVS runtime. The `run` function is the entry point for processing triggers: it receives the trigger data, decodes it, processes it according to your component's logic, and returns the results. Results can be sent back to Ethereum (when triggered by a contract event) or returned as CLI output (when triggered manually during testing). Error handling is done through the `Result` type. In the foundry template, bindings are automatically generated for any files in the `/components` and `/src` directories when the `make build` command is run.

### Building Components

Dependencies for components are added to the `Cargo.toml` file in the `components` directory.

```toml
[dependencies]
# Essential dependencies
wit-bindgen-rt = {workspace = true}    # Required for WASI bindings and Guest trait
wavs-wasi-chain = { workspace = true }  # Required for core WAVS functionality
# Optional dependencies
serde = { workspace = true }            # For serialization (if working with JSON)
serde_json = { workspace = true }       # For JSON handling
alloy-sol-macro = { workspace = true }  # For Ethereum contract interactions
wstd = { workspace = true }             # For WASI standard library features
alloy-sol-types = { workspace = true }  # For Ethereum ABI handling
anyhow = { workspace = true }           # For enhanced error handling
```

**Build Process**:

```bash
# Build the component
make build

# Test locally
make wasi-exec

# Deploy the service
make deploy-service
```

#### Testing

To test your components locally, use the `wasi-exec` command. This command allows you to simulate triggers using the `--input` flag, and you can view the component's logs in stdout/stderr to debug its execution.

```bash
make wasi-exec
```

### `wavs-wasi-chain` crate

The `wavs-wasi-chain` crate provides a set of helpful functions for making HTTP requests and interacting with the blockchain. It also provides a macro for decoding trigger data for use in the component.

Learn more in the [crate documentation](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions).

### Network requests

Components can make network requests to external APIs using the `wavs-wasi-chain` crate.

The following dependencies are useful for making HTTP requests from a component. These are added to a component's `Cargo.toml` file:

```toml Cargo.toml
[dependencies]
wavs-wasi-chain = { workspace = true }  # HTTP utilities
wstd = { workspace = true }             # Runtime utilities
serde = { workspace = true }            # Serialization
serde_json = { workspace = true }       # JSON handling
```

The following example shows how to make a basic HTTP GET request from a component:

```rust lib.rs
async fn make_request() -> Result<YourResponseType, String> {
    // Create the request
    let url = "https://api.example.com/endpoint";
    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    
    // Add headers
    req.headers_mut().insert(
        "Accept",
        HeaderValue::from_static("application/json")
    );
    
    // Make the request and parse JSON response
    let json: YourResponseType = fetch_json(req)
        .await
        .map_err(|e| e.to_string())?;
        
    Ok(json)
}
```

Other functions are available in the [crate documentation](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions).

### Logging

Components can use logging to debug and track the execution of the component.

**Logging in development**:

Use `println!()` to write to stdout/stderr. This is visible when running `wasi-exec` locally.

```rust lib.rs
println!("Debug message: {:?}", data);
```

**Logging in production**

For production, you can use a `host::log()` function which takes a `LogLevel` and writes its output via the tracing mechanism. Along with the string that the developer provides, it attaches additional context such as the `ServiceID`, `WorkflowID`, and component `Digest`.

```rust lib.rs
host::log(LogLevel::Info, "Production logging message");
```

### Blockchain interactions

Components can query Ethereum using the `wavs-wasi-chain` crate:

```rust lib.rs
use wavs_wasi_chain::host;  // For blockchain interactions
use alloy_sol_types::SolValue;  // For ABI encoding/decoding

// Get chain configuration
let chain_config = host::get_eth_chain_config("ethereum")
    .ok_or("Chain config not found")?;

// Make an eth_call
let result = host::eth_call(
    &chain_config,
    "0x...", // contract address
    "0x...", // encoded function call
    "latest" // block tag
).await?;
```

The following dependencies are required in `Cargo.toml` for Ethereum interactions:

```toml Cargo.toml
[dependencies]
wavs-wasi-chain = { workspace = true }  # Blockchain interactions
alloy-sol-types = { workspace = true }  # ABI handling
```

#### Chain configuration

Chain configs are defined in `wavs.toml`. Configs support both HTTP and WebSocket endpoints.Returns encoded ABI data that can be decoded using `alloy-sol-types`.

```toml wavs.toml
[chains.eth.local]
chain_id = "31337"
ws_endpoint = "ws://localhost:8545"
http_endpoint = "http://localhost:8545"
```

For advanced use cases like event decoding and direct blockchain interactions, visit the [wavs-wasi-chain documentation](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions).

### Environment and Configuration Variables

Components can be configured with two types of variables:

#### KV: public variables

These variables can be used for non-sensitive settings and are viewable by anyone. These variables can be configured in the makefile and are set during service deployment. They are accessed using `std::env::var` in the component.

To add public variables, modify the `"kv"` section in the `SERVICE_CONFIG` in your `Makefile`:

```makefile
SERVICE_CONFIG='{
  "fuel_limit": 100000000,
  "max_gas": 5000000,
  "host_envs": ["WAVS_ENV_MY_API_KEY"],
  "kv": [
    ["max_retries", "3"],
    ["timeout_seconds", "30"],
    ["api_endpoint", "https://api.example.com"]
  ],
  "workflow_id": "default",
  "component_id": "default"
}'
```

Then use these variables in your component:

```rust
let max_retries = std::env::var("max_retries")?;
let timeout = std::env::var("timeout_seconds")?;
let endpoint = std::env::var("api_endpoint")?;
```

#### Host environment variables

Private Environment Variables (`host_envs`) can be used for sensitive data like API keys. These variables are set by operators in their environment and are not viewable by anyone. These variables must be prefixed with `WAVS_ENV_`. Each operator must set these variables in their environment before deploying the service. Only variables listed in `host_envs` will be available to the component.

To add private variables, set the environment variable in your `.env` file:

```bash
WAVS_ENV_MY_API_KEY=your_secret_key_here
```

Then modify `"host_envs"` in the `SERVICE_CONFIG` section of your `Makefile`:

   ```json
   "host_envs": ["MY_API_KEY"]
   ```

   - Example: `export WAVS_ENV_COINGECKO_API_KEY=xxxxx`
   - Access in component: `std::env::var("WAVS_ENV_COINGECKO_API_KEY")?`

Configuration is set during service deployment:

```json
SERVICE_CONFIG='{
  "fuel_limit": 100000000,
  "max_gas": 5000000,
  "host_envs": ["WAVS_ENV_MY_API_KEY"],
  "kv": [["max_retries", "3"]],
  "workflow_id": "default",
  "component_id": "default"
}'
```

### Submission

A service handler or submission contract handles the logic for submitting a component's output to the blockchain. A submission contract must implement the `handleSignedData()` function using the `IWavsServiceHandler` interface. This interface is defined in the `@wavs` package: https://www.npmjs.com/package/@wavs/solidity?activeTab=code

In the template, the [submission contract](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/src/contracts/WavsSubmit.sol) uses the `handleSignedData()` function to validate the operator's signature and store the processed data from the component. The `DataWithId` struct must match the output format from the component. Each trigger has a unique ID that links the data to its source.

```solidity
function handleSignedData(bytes calldata _data, bytes calldata _signature) external {
    // 1. Validate the operator's signature by calling the `validate` function on the `_serviceManager` contract
    _serviceManager.validate(_data, _signature);

    // 2. Decode the data into a DataWithId struct defined in the `ITypes` interface
    DataWithId memory dataWithId = abi.decode(_data, (DataWithId));

    // 3. Store the result in state
    _signatures[dataWithId.triggerId] = _signature;      // 1. Store operator signature
    _datas[dataWithId.triggerId] = dataWithId.data;      // 2. Store the data
    _validTriggers[dataWithId.triggerId] = true;         // 3. Mark trigger as valid
}
```


## Example Components

This first component is the main example. It is found in components/eth-price-oracle/src/lib.rs in this repo.

```
// Import required dependencies for Solidity type handling, error handling, and serialization
use alloy_sol_types::SolValue;
use anyhow::Result;
use serde::{Deserialize, Serialize};
// Import WAVS chain utilities for decoding events and making HTTP requests
use wavs_wasi_chain::{
    decode_event_log_data,
    http::{fetch_json, http_request_get},
};
// Import WASI standard library for HTTP headers and async runtime
use wstd::{http::HeaderValue, runtime::block_on};

// Import the generated bindings and required types
use crate::bindings::{export, Guest, TriggerAction};
pub mod bindings;

// Define where the output should be sent - either back to Ethereum or as CLI output
pub enum Destination {
    Ethereum,
    CliOutput,
}

// Function to decode trigger data from either Ethereum events or raw input
pub fn decode_trigger_event(
    trigger_data: bindings::wavs::worker::layer_types::TriggerData,
) -> Result<(u64, Vec<u8>, Destination)> {
    match trigger_data {
        // Handle Ethereum contract events
        bindings::wavs::worker::layer_types::TriggerData::EthContractEvent(
            bindings::wavs::worker::layer_types::TriggerDataEthContractEvent { log, .. },
        ) => {
            // Decode the event log data into a NewTrigger struct
            let event: solidity::NewTrigger = decode_event_log_data!(log)?;
            // Decode the trigger info from the event data
            let trigger_info = solidity::TriggerInfo::abi_decode(&event._triggerInfo, false)?;
            // Return the trigger ID, data, and destination
            Ok((trigger_info.triggerId, trigger_info.data.to_vec(), Destination::Ethereum))
        }
        // Handle raw input (used for CLI testing)
        bindings::wavs::worker::layer_types::TriggerData::Raw(data) => {
            Ok((0, data.clone(), Destination::CliOutput))
        }
        // Reject any other trigger types
        _ => Err(anyhow::anyhow!("Unsupported trigger data type")),
    }
}

// Function to encode the output for submission back to Ethereum
pub fn encode_trigger_output(trigger_id: u64, output: impl AsRef<[u8]>) -> Vec<u8> {
    // Create a DataWithId struct with the trigger ID and output data
    solidity::DataWithId { triggerId: trigger_id, data: output.as_ref().to_vec().into() }
        .abi_encode()
}

// Module for Solidity type definitions
mod solidity {
    use alloy_sol_macro::sol;
    pub use ITypes::*;

    // Generate Rust types from Solidity interface
    sol!("../../src/interfaces/ITypes.sol");
}

// Define the main component struct
struct Component;
// Export the component with the generated bindings
export!(Component with_types_in bindings);

// Implement the Guest trait for the component
impl Guest for Component {
    // Main entry point for processing triggers
    fn run(action: TriggerAction) -> std::result::Result<Option<Vec<u8>>, String> {
        // Decode the trigger data to get trigger ID, request data, and destination
        let (trigger_id, req, dest) =
            decode_trigger_event(action.data).map_err(|e| e.to_string())?;

        // Convert the request bytes to a string
        let input = std::str::from_utf8(&req).map_err(|e| e.to_string())?;
        println!("input id: {}", input);

        // Extract the first character and convert it to a hex digit
        let id = input.chars().next().ok_or("Empty input")?;
        let id = id.to_digit(16).ok_or("Invalid hex digit")? as u64;

        // Make an async request to get price feed data
        let res = block_on(async move {
            let resp_data = get_price_feed(id).await?;
            println!("resp_data: {:?}", resp_data);
            // Convert the response to JSON bytes
            serde_json::to_vec(&resp_data).map_err(|e| e.to_string())
        })?;

        // Return the result based on the destination
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
            Destination::CliOutput => Some(res),
        };
        Ok(output)
    }
}

// Function to fetch price data from CoinMarketCap API
async fn get_price_feed(id: u64) -> Result<PriceFeedData, String> {
    // Construct the API URL with the cryptocurrency ID
    let url = format!(
        "https://api.coinmarketcap.com/data-api/v3/cryptocurrency/detail?id={}&range=1h",
        id
    );

    // Get current timestamp for cookie
    let current_time = std::time::SystemTime::now().elapsed().unwrap().as_secs();

    // Create HTTP request with required headers
    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    req.headers_mut()
        .insert("User-Agent", HeaderValue::from_static("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36"));
    req.headers_mut().insert(
        "Cookie",
        HeaderValue::from_str(&format!("myrandom_cookie={}", current_time)).unwrap(),
    );

    // Fetch and parse the JSON response
    let json: Root = fetch_json(req).await.map_err(|e| e.to_string())?;

    // Extract relevant data from the response
    Ok(PriceFeedData {
        symbol: json.data.symbol,
        price: json.data.statistics.price,
        timestamp: json.status.timestamp,
    })
}

// Struct to hold the price feed data
#[derive(Debug, Serialize, Deserialize)]
pub struct PriceFeedData {
    symbol: String,
    timestamp: String,
    price: f64,
}

// Structs for parsing the CoinMarketCap API response
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Root {
    pub data: Data,
    pub status: Status,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Data {
    pub id: f64,
    pub name: String,
    pub symbol: String,
    pub statistics: Statistics,
    pub description: String,
    pub category: String,
    pub slug: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Statistics {
    pub price: f64,
    #[serde(rename = "totalSupply")]
    pub total_supply: f64,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CoinBitesVideo {
    pub id: String,
    pub category: String,
    #[serde(rename = "videoUrl")]
    pub video_url: String,
    pub title: String,
    pub description: String,
    #[serde(rename = "previewImage")]
    pub preview_image: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Status {
    pub timestamp: String,
    pub error_code: String,
    pub error_message: String,
    pub elapsed: String,
    pub credit_count: f64,
}

```

### Other examples

The following components are supplemental examples.

### Prediction Market Oracle
```rust
#[allow(warnings)]
mod bindings;
use bindings::{export, Guest, TriggerAction};
mod trigger;
use serde::{Deserialize, Serialize};
use trigger::{decode_trigger_event, encode_trigger_output};
use wavs_wasi_chain::http::{fetch_json, http_request_get};
use wstd::{http::HeaderValue, runtime::block_on};

struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        // Decode trigger data containing market parameters
        let (trigger_info, data) = decode_trigger_event(action.data)?;

        // Fetch current Bitcoin price from CoinMarketCap
        let bitcoin_price = block_on(get_price_feed(1))?;

        // Market resolution logic: YES if Bitcoin price > $1
        let result = bitcoin_price > 1.0;

        // Encode result with market parameters for on-chain submission
        Ok(encode_trigger_output(
            trigger_info.triggerId,
            data.lmsrMarketMaker,
            data.conditionalTokens,
            result,
        ))
    }
}

// Fetches price data from CoinMarketCap API
async fn get_price_feed(id: u64) -> Result<f64, String> {
    let url = format!(
        "https://api.coinmarketcap.com/data-api/v3/cryptocurrency/detail?id={}&range=1h",
        id
    );

    // Add required headers for API request
    let current_time = std::time::SystemTime::now().elapsed().unwrap().as_secs();
    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    req.headers_mut()
        .insert("User-Agent", HeaderValue::from_static("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36"));
    req.headers_mut().insert(
        "Cookie",
        HeaderValue::from_str(&format!("myrandom_cookie={}", current_time)).unwrap(),
    );

    // Parse JSON response into structured data
    let json: Root = fetch_json(req).await.map_err(|e| e.to_string())?;
    Ok(json.data.statistics.price)
}

// API response data structures
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Root {
    pub data: Data,
    pub status: Status,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Data {
    pub id: f64,
    pub name: String,
    pub symbol: String,
    pub statistics: Statistics,
    pub description: String,
    pub category: String,
    pub slug: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Statistics {
    pub price: f64,
    #[serde(rename = "totalSupply")]
    pub total_supply: f64,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Status {
    pub timestamp: String,
    pub error_code: String,
    pub error_message: String,
    pub elapsed: String,
    pub credit_count: f64,
}
```

Key features:
- Fetches Bitcoin price from CoinMarketCap API
- Resolves market based on price threshold
- Uses LMSR market maker and conditional tokens for settlement
- Handles API authentication and rate limiting
- Structured response parsing with Serde

### Safe-Guard Component
```rust
#[allow(warnings)]
mod bindings;
use alloy_sol_types::{sol, SolValue};  // For Solidity type definitions and ABI encoding
use bindings::{
    export,
    wavs::worker::layer_types::{TriggerData, TriggerDataEthContractEvent},
    Guest, TriggerAction,
};
use wavs_wasi_chain::decode_event_log_data;  // For decoding Ethereum event logs

// Define Solidity event and struct types using alloy-sol-types
sol! {
    #[derive(Debug)]
    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);

    #[derive(Debug)]
    struct ValidationPayload {
        bytes32 approvedHash;
        bool approved;
    }
}

struct Component;

impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        match trigger_action.data {
            // Handle Ethereum contract events
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {
                // Decode ApproveHash event from log data
                let ApproveHash { approvedHash, .. } = decode_event_log_data!(log)
                    .map_err(|e| format!("Failed to decode event log data: {}", e))?;

                // Create and encode validation payload
                Ok(ValidationPayload { approvedHash, approved: true }.abi_encode())
            }
            _ => Err("Unsupported trigger data".to_string()),
        }
    }
}

export!(Component with_types_in bindings);
```

Key features:
- Decodes Ethereum contract events using `decode_event_log_data!` macro
- Uses `alloy-sol-types` for Solidity type definitions and ABI encoding
- Implements validation logic for transaction approval
- Returns encoded validation payload for on-chain processing
- Handles only Ethereum contract events, rejects other trigger types

### DAO Agent Component
```rust
mod bindings;
mod context;
mod integration_tests;
mod models;
mod ollama;

use alloy_primitives::{Address, Bytes, U256};  // For Ethereum primitive types
use alloy_sol_types::{sol, SolCall, SolType, SolValue};  // For Solidity type definitions
use anyhow::Result;
use bindings::{
    export,
    wavs::worker::layer_types::{TriggerData, TriggerDataEthContractEvent},
    Guest, TriggerAction,
};
use models::{DaoContext, SafeTransaction};  // Custom types for DAO context and transactions
use ollama::OllamaChatResponse;  // For Ollama API responses
use serde_json::json;
use std::str::FromStr;
use wstd::{
    http::{Client, IntoBody, Request},
    io::AsyncRead,
    runtime::block_on,
};

// Define Solidity interface for ERC20 token interactions
sol! {
    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
    }

    #[derive(Debug)]
    struct TransactionPayload {
        address to;
        uint256 value;
        bytes data;
    }
}

struct Component;

impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        match trigger_action.data {
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {
                // Decode the prompt from the event data
                let decoded = alloy_sol_types::sol_data::String::abi_decode(&log.data, false)
                    .map_err(|e| format!("Failed to decode ABI string: {}", e))?;

                let prompt = decoded.to_string();

                return block_on(async move {
                    // Query Ollama for transaction decision
                    let response = query_ollama(&prompt).await?;

                    println!("Response: {}", response);

                    // Extract tool call or return no-op if none found
                    let tool_call = match response
                        .split("<tool_call>")
                        .nth(1)
                        .and_then(|s| s.split("</tool_call>").next())
                    {
                        Some(call) => call,
                        None => {
                            // Return no-op transaction if no tool call found
                            let no_op = create_no_op_transaction("No action needed");
                            let payload = create_payload_from_safe_tx(&no_op)?;
                            return Ok(payload.abi_encode().to_vec());
                        }
                    };

                    // Parse and validate transaction
                    let transaction: SafeTransaction = serde_json::from_str(tool_call)
                        .map_err(|e| format!("Failed to parse transaction: {}", e))?;

                    // Validate destination address
                    if transaction.to.is_empty()
                        || transaction.to == "0x"
                        || transaction.to.len() < 42
                    {
                        let no_op = create_no_op_transaction("Invalid or missing destination address");
                        let payload = create_payload_from_safe_tx(&no_op)?;
                        return Ok(payload.abi_encode().to_vec());
                    }

                    // Create and encode transaction payload
                    let payload = create_payload_from_safe_tx(&transaction)?;
                    println!("Payload: {:?}", payload);
                    Ok(payload.abi_encode().to_vec())
                });
            }
            _ => Err("Unsupported trigger data".to_string()),
        }
    }
}

// Helper function to create no-op transactions
fn create_no_op_transaction(reason: &str) -> SafeTransaction {
    SafeTransaction {
        to: "0x0000000000000000000000000000000000000000".to_string(),
        value: "0".to_string(),
        contract_call: None,
        data: "0x".to_string(),
        description: format!("No action taken: {}", reason),
    }
}

// Convert SafeTransaction to TransactionPayload
fn create_payload_from_safe_tx(tx: &SafeTransaction) -> Result<TransactionPayload, String> {
    // Parse and validate address
    let to: Address = tx.to.parse().map_err(|e| format!("Invalid address: {}", e))?;
    let value = U256::from_str(&tx.value).map_err(|e| format!("Invalid value: {}", e))?;

    // Handle contract calls (e.g., ERC20 transfers)
    let data = if let Some(contract_call) = &tx.contract_call {
        match contract_call.function.as_str() {
            "transfer" => {
                let recipient = contract_call.args[0]
                    .as_str()
                    .ok_or("Missing recipient")?
                    .parse::<Address>()
                    .map_err(|e| format!("Invalid recipient address: {}", e))?;
                let amount = U256::from_str(contract_call.args[1].as_str().ok_or("Missing amount")?)
                    .map_err(|e| format!("Invalid amount: {}", e))?;

                let call = IERC20::transferCall { recipient, amount };
                Bytes::from(call.abi_encode())
            }
            _ => Bytes::default(),
        }
    } else {
        Bytes::default()
    };

    Ok(TransactionPayload { to, value, data })
}

// Query Ollama API for transaction decisions
async fn query_ollama(prompt: &str) -> Result<String, String> {
    let context = DaoContext::default();

    // Format contract information for system prompt
    let contract_descriptions = context
        .contracts
        .iter()
        .map(|contract| {
            format!(
                "Contract: {}\nAddress: {}\nABI:\n{}",
                contract.name, contract.address, contract.abi
            )
        })
        .collect::<Vec<_>>()
        .join("\n\n");

    // Construct system prompt with DAO context and security rules
    let system_prompt = format!(
        r#"
        You are a function calling AI model with a list of smart contracts and their ABIs in <tools></tools> XML tags, a DAO agent 
        responsible for making and executing decisions through a Gnosis Safe Module.

        Current DAO Context:
        - Safe Address: {}
        - Current Balances:
        {}
        - Allowed Addresses: {}
        - DAO Mission: {}
        - Allowed Tokens: ONLY native ETH and USDC are supported. All other token requests should be rejected.

        Available Smart Contracts:
        <tools>
        {}
        </tools>

        REQUIRED JSON FIELDS - ALL MUST BE INCLUDED:
        1. "to": destination address
        2. "value": amount in wei
        3. "data": MUST be included and set to "0x" for simple transfers
        4. "description": explanation of the action
        5. "contract_call": (optional) only for token transfers

        STRICT JSON RULES:
        - NO comments in JSON
        - NO trailing commas
        - NO explanatory text inside JSON
        - ALL fields above must be present
        - The "data" field must ALWAYS be included
        - JSON must be strictly valid

        Examples:

        1. Simple ETH transfer:
        <tool_call>
        {{
            "to": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
            "value": "1000000000000000000",
            "data": "0x",
            "description": "Sending 1 ETH to specified address"
        }}
        </tool_call>

        2. USDC transfer:
        <tool_call>
        {{
            "to": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
            "value": "0",
            "data": "0x",
            "contract_call": {{
                "function": "transfer",
                "args": ["0x742d35Cc6634C0532925a3b844Bc454e4438f44e", "1000000"]
            }},
            "description": "Sending 1 USDC to specified address"
        }}
        </tool_call>

        3. No action needed:
        <tool_call>
        {{
            "to": "0x0000000000000000000000000000000000000000",
            "value": "0",
            "data": "0x",
            "description": "No action needed: [reason]"
        }}
        </tool_call>

        Security Guidelines:
        - Always verify addresses are in the allowed list or contract list
        - Include the contract_call field in the JSON if a contract call is needed
        - When making a smart contract call, ALWAYS use the contract address in the "to" field
        - If using an ERC20 token (such as USDC), ALWAYS use the contract address in the "to" field
        - Never approve transactions that would spend more than the current balance
        - Be extremely cautious with value transfers
        - Reject any suspicious or unclear requests
        - Don't allow transfers of amounts greater than 1 ETH
        - IMMEDIATELY REJECT any requests for tokens other than ETH or USDC with a no-op transaction
        - ALWAYS output JSON within <tool_call></tool_call> XML tags
        - ALWAYS end your response with JSON wrapped in <tool_call></tool_call> XML tags
        - NEVER wrap <tool_call></tool_call> with anything including markdown formatting
    "#,
        context.safe_address,
        context.format_balances(),
        context.allowed_addresses.join(", "),
        context.dao_description,
        contract_descriptions,
    );

    // Make request to Ollama API
    let req = Request::post("http://localhost:11434/api/chat")
        .body(
            serde_json::to_vec(&json!({
                "model": "llama3.1",
                "messages": [{
                    "role": "system",
                    "content": system_prompt
                }, {
                    "role": "user",
                    "content": prompt
                }],
                "options": {
                    "temperature": 0.0,        // Deterministic output
                    "top_k": 1,               // Strict selection
                    "top_p": 0.1,             // Narrow sampling
                    "min_p": 0.0,             // Disabled
                    "num_ctx": 4096,          // Context window
                    "num_predict": 500,       // Max tokens
                    "seed": 42,               // Fixed seed
                },
                "stream": false
            }))
            .unwrap()
            .into_body(),
        )
        .unwrap();

    // Send request and handle response
    let mut res = Client::new().send(req).await.map_err(|e| e.to_string())?;

    if res.status() != 200 {
        return Err(format!("Ollama API error: status {}", res.status()));
    }

    let mut body_buf = Vec::new();
    res.body_mut().read_to_end(&mut body_buf).await.unwrap();

    let resp = String::from_utf8_lossy(&body_buf);
    let resp = serde_json::from_str::<OllamaChatResponse>(format!(r#"{}"#, resp).as_str());

    match resp {
        Ok(OllamaChatResponse::Success(success)) => Ok(success.message.content),
        Ok(OllamaChatResponse::Error { error }) => Err(error),
        Err(e) => Err(format!("Failed to parse response: {}", e)),
    }
}

export!(Component with_types_in bindings);
```

Key features:
- Uses Ollama API for AI-powered transaction decisions
- Implements strict security rules for transaction validation
- Supports ETH and USDC transfers with proper contract calls
- Handles no-op transactions for rejected requests
- Uses deterministic AI parameters for consistent decisions
- Validates addresses and amounts before execution
- Provides detailed transaction descriptions
- Implements proper error handling and logging

### ETH-Cosmos Bridge Component
```rust
use alloy_sol_macro::sol;  // For Solidity type definitions
use alloy_sol_types::SolValue;  // For ABI encoding
use bindings::{
    export,
    wavs::worker::layer_types::{
        TriggerData, TriggerDataCosmosContractEvent, TriggerDataEthContractEvent,
    },
    Guest, TriggerAction,
};
use trigger_contract::event::NewDepositEvent;  // For Cosmos deposit event handling

mod bindings;

struct Component;

impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        match trigger_action.data {
            // Handle Ethereum contract events (placeholder for future implementation)
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { .. }) => {}
            
            // Handle Cosmos contract events
            TriggerData::CosmosContractEvent(TriggerDataCosmosContractEvent { event, .. }) => {
                // Check for deposit events from Cosmos chain
                if event.ty.as_str() == NewDepositEvent::KEY
                    || event.ty.as_str() == format!("wasm-{}", NewDepositEvent::KEY)
                {
                    // Extract event attributes
                    let mut amount = None;
                    let mut sender = None;
                    let mut recipient = None;

                    // Parse event attributes
                    for (key, value) in event.attributes.into_iter() {
                        match key.as_str() {
                            "amount" => amount = Some(value),
                            "sender" => sender = Some(value),
                            "recipient" => recipient = Some(value),
                            _ => {}
                        }
                    }

                    // Process deposit event if all required fields are present
                    match (amount, sender, recipient) {
                        (Some(amount), Some(sender), Some(recipient)) => {
                            let response = BridgeDeposit {
                                amount: amount
                                    .parse()
                                    .map_err(|e| format!("Failed to parse amount: {}", e))?,
                                sender,
                                recipient: alloy_primitives::Address::parse_checksummed(
                                    recipient, None,
                                )
                                .map_err(|e| format!("Failed to parse recipient: {}", e))?,
                            };

                            return Ok(response.abi_encode());
                        }
                        _ => {}
                    }
                }
            }
            // Handle raw trigger data (placeholder for future implementation)
            TriggerData::Raw(_) => {}
        };

        Ok(Vec::new())
    }
}

// Import Solidity types from contract
sol!("../contracts/solidity/Types.sol",);

export!(Component with_types_in bindings);
```

Key features:
- Handles cross-chain bridge events between Ethereum and Cosmos
- Processes Cosmos deposit events with amount, sender, and recipient
- Validates and parses Ethereum addresses
- Supports both standard and WASM event types
- Returns encoded bridge deposit data for on-chain processing
- Implements proper error handling for parsing failures
- Uses Solidity type definitions for consistent data structures
- Extensible for future ETH-to-Cosmos event handling

### Telegram Bot Component
```rust
mod bindings;
mod telegram;  // Module for Telegram API interactions

use alloy_sol_types::SolValue;  // For ABI encoding
use bindings::{
    export,
    wavs::worker::layer_types::{TriggerData, TriggerDataEthContractEvent},
    Guest, TriggerAction,
};
use serde_json::json;  // For JSON handling
use std::str::FromStr;
use wstd::{
    http::{Client, IntoBody, Request},
    io::AsyncRead,
    runtime::block_on,
};

struct Component;

impl Guest for Component {
    fn run(trigger_action: TriggerAction) -> std::result::Result<Vec<u8>, String> {
        match trigger_action.data {
            // Handle Ethereum contract events
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {
                // Decode the message from the event data
                let decoded = alloy_sol_types::sol_data::String::abi_decode(&log.data, false)
                    .map_err(|e| format!("Failed to decode ABI string: {}", e))?;

                let message = decoded.to_string();

                return block_on(async move {
                    // Send message to Telegram
                    let response = send_telegram_message(&message).await?;

                    println!("Telegram response: {}", response);

                    // Return success response
                    Ok(Vec::new())
                });
            }
            _ => Err("Unsupported trigger data".to_string()),
        }
    }
}

// Send message to Telegram API
async fn send_telegram_message(message: &str) -> Result<String, String> {
    // Get bot token from environment
    let bot_token = std::env::var("TELEGRAM_BOT_TOKEN")
        .map_err(|e| format!("Failed to get TELEGRAM_BOT_TOKEN: {}", e))?;

    // Get chat ID from environment
    let chat_id = std::env::var("TELEGRAM_CHAT_ID")
        .map_err(|e| format!("Failed to get TELEGRAM_CHAT_ID: {}", e))?;

    // Construct Telegram API URL
    let url = format!(
        "https://api.telegram.org/bot{}/sendMessage",
        bot_token
    );

    // Create request body
    let body = json!({
        "chat_id": chat_id,
        "text": message,
        "parse_mode": "HTML"
    });

    // Create HTTP request
    let req = Request::post(&url)
        .body(
            serde_json::to_vec(&body)
                .unwrap()
                .into_body(),
        )
        .unwrap();

    // Send request
    let mut res = Client::new().send(req).await.map_err(|e| e.to_string())?;

    if res.status() != 200 {
        return Err(format!("Telegram API error: status {}", res.status()));
    }

    // Read response body
    let mut body_buf = Vec::new();
    res.body_mut().read_to_end(&mut body_buf).await.unwrap();

    // Parse response
    let resp = String::from_utf8_lossy(&body_buf);
    Ok(resp.to_string())
}

export!(Component with_types_in bindings);
```

Key features:
- Handles Ethereum contract events for message triggers
- Sends messages to Telegram using Bot API
- Uses environment variables for bot configuration
- Supports HTML formatting in messages
- Implements proper error handling
- Uses async/await for API requests
- Returns empty vector on success (no on-chain data needed)
- Logs API responses for debugging

### Common Data Structures and Interfaces

```rust
// Trigger data structure used across components
pub struct TriggerData {
    pub trigger_id: [u8; 32],
    pub data: Vec<u8>,
    pub destination: Destination,
}

// Market resolution interface
sol! {
    interface IMarketResolver {
        function resolveMarket(bytes32 marketId, bool outcome) external;
    }
}

// Bridge deposit structure
sol! {
    struct BridgeDeposit {
        uint256 amount;
        string sender;
        address recipient;
    }
}

// Safe transaction interface
sol! {
    struct SafeTransaction {
        address to;
        uint256 value;
        bytes data;
        string description;
        ContractCall contract_call;
    }

    struct ContractCall {
        string function;
        string[] args;
    }
}

// Telegram message structure
#[derive(Serialize, Deserialize)]
pub struct TelegramMessage {
    pub chat_id: String,
    pub text: String,
    pub parse_mode: Option<String>,
}

// DAO context structure
#[derive(Default)]
pub struct DaoContext {
    pub safe_address: String,
    pub balances: HashMap<String, String>,
    pub allowed_addresses: Vec<String>,
    pub dao_description: String,
    pub contracts: Vec<ContractInfo>,
}

#[derive(Default)]
pub struct ContractInfo {
    pub name: String,
    pub address: String,
    pub abi: String,
}
```

### Configuration Examples

```toml
# Example wavs.toml for component configuration
[service]
name = "example-service"
version = "0.1.0"

[chains]
ethereum = { rpc_url = "http://localhost:8545" }
cosmos = { rpc_url = "http://localhost:26657" }

[components]
prediction_market = { wasm = "prediction_market.wasm" }
safe_guard = { wasm = "safe_guard.wasm" }
dao_agent = { wasm = "dao_agent.wasm" }
bridge = { wasm = "bridge.wasm" }
telegram_bot = { wasm = "telegram_bot.wasm" }

[environment]
TELEGRAM_BOT_TOKEN = "${TELEGRAM_BOT_TOKEN}"
TELEGRAM_CHAT_ID = "${TELEGRAM_CHAT_ID}"
COINMARKETCAP_API_KEY = "${COINMARKETCAP_API_KEY}"
```
