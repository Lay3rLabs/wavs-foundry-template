---
title: Custom Component Handbook
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

{/* todo: move all contents from this file to appropriate files in this directory then delete this file.  */}

<Callout title="Follow the tutorial" type="info">

Before reading this guide, follow the [Oracle component tutorial](/tutorial/1-overview) to learn the basics of building a WAVS service.

</Callout>

Use the info in this guide to customize the template to create your own custom service. Check out the [WAVS design considerations](/design) page to learn which use-cases WAVS is best suited for.

## Foundry Template structure

The foundry template is made up of the following main files:

```bash
wavs-foundry-template/
├── README.md
├── makefile               # Commands, variables, and configs
├── components/            # WASI components
│   └── eth-price-oracle/
│       ├── Cargo.toml     # Component dependencies
│       ├── lib.rs         # Main Component logic
│       ├── trigger.rs     # Trigger handling
│       └── bindings.rs    # Bindings generated by `make build`
├── compiled/              # WASM files compiled by `make build`
├── src/
│   ├── contracts/        # Trigger and submission contracts
│   └── interfaces/       # Solidity interfaces
├── script/               # Scripts used in makefile commands
├── cli.toml              # CLI configuration
├── wavs.toml             # WAVS service configuration
├── docs/                 # Documentation
└── .env                  # Private environment variables
```

- The `README` file contains the tutorial commands.
- The `makefile` contains commands for building and deploying the service. It also contains variables and configs for the service.
- The components directory contains the component logic for your service. Running `make wasi-build` will automatically generate bindings and compile components into the `compiled` directory.
- The src directory contains the Solidity contract and interfaces.
- The script directory contains the scripts used in the makefile commands to deploy, trigger, and test the service.
- The `.env` file contains private environment variables and keys. Use `cp .env.example .env` to copy the example `.env` file.

## WAVS services

The basic service is made up of a trigger, a component, and submission logic (optional).

[Trigger](#triggers): any onchain event emitted from a contract.

[Component](#components): the main logic of a WAVS service. Components are responsible for processing the trigger data and executing the business logic.

[Submission](#submission): handles the logic for submitting a component's output to the blockchain.




## Makefile commands

The makefile contains several commands for building, testing, and deploying WAVS components. Here's a detailed explanation of the most commonly used commands:

#### Building and Testing Components

1. Build your WASI components

```bash
make wasi-build
```
**Under the hood**:
  - Iterates over all components found in the `components` directory.
  - Automatically generates WASI bindings for each component.
  - Runs `cargo component build --release` to compile the components.
  - Formats the code using `cargo fmt`.
  - Copies the compiled `.wasm` files to the `compiled` directory.

2. Test your WASI components directly without deploying to a chain.

```bash
COIN_MARKET_CAP_ID=1 make wasi-exec
```

**Under the hood**:
  - Uses the `wavs-cli` Docker image to run the component specified by `COMPONENT_FILENAME`.
  - Simulates the trigger event using the `COIN_MARKET_CAP_ID` as the input and the `SERVICE_CONFIG` to configure the service.
  - Executes the component with the input data.
  - Can handle input data in three formats:
    - `@file`: Reads input from a file
    - `0x`: Treats input as hex-encoded bytes
    - Raw string: Treats input as raw bytes (you may need to format the input data appropriately before passing it to the component)
  - For the `ETH_PRICE_ORACLE` component, the input data must be formatted into a `bytes32` string. This is done in the makefile's `wasi-exec` command using ``--input `cast format-bytes32-string $(COIN_MARKET_CAP_ID)```. When creating your own components, update the makefile to use the appropriate format for your use case.

**Variables**:
  - `COMPONENT_FILENAME`: The path of the compiled WASM file to execute.
  - `COIN_MARKET_CAP_ID`: The input data used to simulate the trigger event.
  - `SERVICE_CONFIG`: The service configuration for the component containing the `host_envs` and `kv` variables.

#### Setup

```bash
make setup
```
- **Purpose**: Installs initial dependencies required for the project.
- **Under the hood**:
  - Checks for system requirements like Node.js, jq, and cargo.
  - Installs dependencies using `forge install` and `npm install`.

```bash
forge build
```
- **Purpose**: Builds the Solidity contracts.
- **Under the hood**:
  - Compiles the Solidity contracts using Foundry's `forge` tool.

```bash
forge test
```
- **Purpose**: Runs tests for the Solidity contracts.
- **Under the hood**:
  - Executes the test suite using Foundry's `forge test` command.

#### Starting Services

```bash
make start-all
```

- Starts the Anvil Ethereum node and WAVS using Docker Compose. Keep this running and open another terminal to execute other commands.
- **Under the hood**:
  - Cleans up any existing Docker containers.
  - Starts the Anvil Ethereum node directly on the host.
  - Runs `docker compose up` which:
    - Starts the main `wavs` service and the `aggregator` service.
    - Deploys EigenLayer core contracts for local development and your Service Manager contract which manages your AVS.

#### Deployment and Execution

```bash
export SERVICE_MANAGER_ADDR=`make get-eigen-service-manager-from-deploy`
forge script ./script/Deploy.s.sol ${SERVICE_MANAGER_ADDR} --sig "run(string)" --rpc-url http://localhost:8545 --broadcast
```

- **Under the hood**:
  1. Retrieves the deployed service manager address from `.docker/deployments.json`.
  2. Deploys the on-chain trigger and submission contracts.
  3. Links the submission contract to the Service Manager by passing the `_serviceManagerAddr` to its constructor.
  4. Saves the deployed contract addresses in `.docker/script_deploy.json`
  5. Uses the specified RPC URL to interact with the Ethereum node.
  6. Broadcasts the transaction to the network.

```bash
TRIGGER_EVENT="NewTrigger(bytes)" COMPONENT_FILENAME=usdt_balance.wasm make deploy-service
```
- **Purpose**: Registers the WASI component as a service with the WAVS network.
- **Under the hood**:
  1. Registers the service with the following configuration:
    - Specifies the compiled component to run (`--component`)
    - Sets the trigger event to watch for (`--trigger-event-name`)
    - Configures the trigger contract address (`--trigger-address`)
    - Configures the submission contract address (`--submit-address`)
    - Applies service configuration including fuel limits, gas limits, and environment variables (`--service-config`).
  2. The service configuration is stored off-chain and used by the WAVS operator to run the component

```bash
export COIN_MARKET_CAP_ID=1
export SERVICE_TRIGGER_ADDR=`make get-trigger-from-deploy`
forge script ./script/Trigger.s.sol ${SERVICE_TRIGGER_ADDR} ${COIN_MARKET_CAP_ID} --sig "run(string,string)" --rpc-url http://localhost:8545 --broadcast -v 4
```

- **Under the hood**:
  - Exports the `COIN_MARKET_CAP_ID` environment variable for use in subsequent commands.
  - Uses `jq` to extract the trigger address from `.docker/script_deploy.json`.
  - Executes the `Trigger.s.sol` script with the trigger address and `COIN_MARKET_CAP_ID`.
  - Uses the specified RPC URL to interact with the local Anvil node.
  - Broadcasts the transaction to the network.

#### Viewing Results

```bash
make show-result
```

- Uses the `ShowResult.s.sol` script to retrieve and display the result from the service.


### Makefile variables

The Makefile contains several important variables that control the behavior of the WAVS service.

#### Component variable

```bash
COMPONENT_FILENAME ?= eth_price_oracle.wasm
```

- Used by `wasi-exec` and `deploy-service` commands to identify which component to run or deploy.
- Change this filename to run a different service.

#### Service config

```bash
SERVICE_CONFIG ?= '{"fuel_limit":100000000,"max_gas":5000000,"host_envs":[],"kv":[],"workflow_id":"default","component_id":"default"}'
```

- Configures the WAVS service.
  - `fuel_limit`: Maximum computational resources the service can use
  - `max_gas`: Maximum gas limit for blockchain transactions
  - `host_envs`: List of private environment variables to expose to the component (values must be prefixed with `WAVS_ENV_`)
  - `kv`: Key-value pairs for public configuration
  - `workflow_id` and `component_id` are set as `default` in the template for simple services.

#### Network configuration

```bash
RPC_URL ?= http://localhost:8545
```

- Specifies the Ethereum RPC endpoint URL.

#### Trigger event

```bash
TRIGGER_EVENT ?= NewTrigger(bytes)
```

- Defines the event signature that WAVS will watch for on the blockchain.
- With WAVS, this can either be a hex-encoded event signature or an event name.
- `NewTrigger(bytes)` in this example is the trigger event from the template's trigger contract.

#### Trigger data

```bash
COIN_MARKET_CAP_ID ?= 1
```
- Specifies the `COIN_MARKET_CAP_ID` for testing the price oracle in `wasi-exec` and trigger scripts (`1` is the ID of Bitcoin in the `Eth-price-oracle` example).
- In the `ETH_PRICE_ORACLE` component, the input data needs to be formatted into a `bytes32` string in the `make wasi-exec` makefile command using `cast format-bytes32-string`. When creating your own components, update the makefile to use an appropriate format for your use case.

#### Contract addresses

```bash
SERVICE_MANAGER_ADDR ?= `jq -r '.eigen_service_managers.local | .[-1]' .docker/deployments.json`
SERVICE_TRIGGER_ADDR ?= `jq -r '.trigger' "./.docker/script_deploy.json"`
SERVICE_SUBMISSION_ADDR ?= `jq -r '.service_handler' "./.docker/script_deploy.json"`
```
- Automatically populated from deployment JSON files. Used by deployment and interaction commands.
- You can view the addresses of your deployed contracts using these commands:

View the addresses of your deployed contracts using these commands:

```bash
# View the trigger contract address
make get-trigger-from-deploy
# View the submission contract address
make get-service-handler-from-deploy
# View the service manager address
make get-eigen-service-manager-from-deploy
```

#### Customizing Makefile variables

Makefile variables can be overridden when running make commands. For example, running the following in your terminal will use a different component when testing:

```bash
COMPONENT_FILENAME=my_component.wasm COIN_MARKET_CAP_ID=1 make wasi-exec
```

To trigger the component from an external contract, you can set the trigger address and trigger event manually in the makefile:

```bash
TRIGGER_ADDRESS ?= 0x1234567890123456789012345678901234567890
TRIGGER_EVENT ?= MyCustomEvent(bytes)
```
{/* todo: link here: */}
You can also add variables to the makefile, such as public variables to be referenced in your component or reference private variables like API keys. Find out more in the [Environment Variables](#environment-variables) section.

## Toml files

There are several toml files in the template that are used to configure the service:

- `wavs.toml` is used to configure the WAVS service itself, including chain configurations (local, testnets, mainnet) and maximum WASM fuel limits.
- `cli.toml` is used to configure the WAVS CLI tool, and also includes chain configurations (local, testnets, mainnet), maximum WASM fuel limits, and log levels.
- `Cargo.toml` in the root directory is used to configure the workspace and includes dependencies, build settings, and component metadata.
- `/components/*/Cargo.toml` in each component directory is used to configure the Rust component and includes dependencies, build settings, and component metadata. It can inherit dependencies from the root `Cargo.toml` file using `workspace = true`.

These files can be customized to suit your specific needs, and many settings can be overridden using environment variables.

The following is an example of a component's `Cargo.toml` file structure:

```toml
# Package metadata - inherits most values from workspace configuration
[package]
name = "eth-price-oracle"        # Name of the component
edition.workspace = true         # Rust edition (inherited from workspace)
version.workspace = true         # Version (inherited from workspace)
authors.workspace = true         # Authors (inherited from workspace)
rust-version.workspace = true    # Minimum Rust version (inherited from workspace)
repository.workspace = true      # Repository URL (inherited from workspace)

# Component dependencies
[dependencies]
# Core dependencies
wit-bindgen-rt = {workspace = true}    # Required for WASI bindings and Guest trait
wavs-wasi-chain = { workspace = true }  # Required for core WAVS functionality
# Helpful dependencies
serde = { workspace = true }            # For serialization (if working with JSON)
serde_json = { workspace = true }       # For JSON handling
alloy-sol-macro = { workspace = true }  # For Ethereum contract interactions
wstd = { workspace = true }             # For WASI standard library features
alloy-sol-types = { workspace = true }  # For Ethereum ABI handling
anyhow = { workspace = true }           # For enhanced error handling

# Library configuration
[lib]
crate-type = ["cdylib"]  # Specifies this is a dynamic library crate

# Release build optimization settings
[profile.release]
codegen-units = 1        # Single codegen unit for better optimization
opt-level = "s"          # Optimize for size
debug = false            # Disable debug information
strip = true            # Strip symbols from binary
lto = true              # Enable link-time optimization

# WAVS component metadata
[package.metadata.component]
package = "component:eth-price-oracle"  # Component package name
target = "wavs:worker/layer-trigger-world@0.3.0"  # Target WAVS world and version
```

