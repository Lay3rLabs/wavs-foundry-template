---
title: Triggers
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->


{/* todo: verify examples, add info on triggerdata and decode trigger data. Multi-chain services blurb goes here. add info on trigger data in components and link to inputs/outputs on component page (or move here?? dunno).  */}

A trigger prompts a WAVS service to run. Operators listen for the trigger event specified by the service and execute the corresponding component off-chain. Triggers can be any onchain event emitted from any contract.

### Trigger lifecycle

1. When a service is deployed, it is configured with a trigger address and event, a wasi component, and a submission contract (optional).

2. Registered operators listen to chain logs. Each operator maintains lookup maps and verifies events against registered triggers.

3. When a trigger event is emitted, operators pick up the event and verify the event matches the registered trigger.

4. If a match is found, WAVS creates a `TriggerAction` that wraps the trigger event data:

```rust
TriggerAction {
    // Service and workflow identification
    config: TriggerConfig {
       service_id: ServiceID,      // Generated during deployment
        workflow_id: WorkflowID,    // Default or specified
        trigger: Trigger::EthContractEvent {
           address: Address,       // Contract address
            chain_name: ChainName,  // Chain identifier
            event_hash: ByteArray<32> // Event signature
        }
    },
   // The actual event data
    data: TriggerData::EthContractEvent {
        contract_address: Address,  // Emitting contract
        chain_name: ChainName,      // Source chain
        log: LogData {             // Raw event data
            topics: Vec<Vec<u8>>,  // Event signature + indexed params
            data: Vec<u8>         // ABI-encoded event data
        },
        block_height: u64         // Block number
    }
}
```

5. The TriggerAction is converted to a WASI-compatible format and passed to the component where it is decoded and processed.

### Developing triggers

WAVS doesn't interpret the contents of event triggers. Instead, it passes the raw log data to components, which can decode and process the data according to their specific needs.

To configure a trigger for a service, you'll need to specify:

- The event signature/name that identifies which specific event should trigger the service. This can either be a hex-encoded event signature or an event name.
- The contract address where the event will be emitted from.

In the template, the trigger event is set in the `Makefile` as `TRIGGER_EVENT ?= NewTrigger(bytes)` and the trigger address of the example trigger contract is automatically populated during deployment. To change the trigger event or address, you can manually [update the `Makefile` variables](#customizing-makefile-variables) and redeploy the service.

When a WAVS component receives this trigger, it uses the `decode_event_log_data!` macro from the [`wavs-wasi-chain`](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions) crate to decode the event data for processing.

The [trigger contract in the WAVS foundry template](https://github.com/Lay3rLabs/wavs-foundry-template/blob/v0.3.0/src/contracts/WavsTrigger.sol) is a simple example that takes generic bytes and passes them to the component. The flow for triggers is located in several places in the template:

- The trigger contract in [`src/WavsTrigger.sol`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/src/contracts/WavsTrigger.sol) defines how triggers are created and emitted on-chain.
- The trigger script in [`/script/Trigger.s.sol`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/script/Trigger.s.sol#L15) calls the `addTrigger` function with the `coinMarketCapID`.
- The `decode_trigger_event` function in [`/components/eth-price-oracle/src/trigger.rs`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/components/eth-price-oracle/src/trigger.rs#L11-L21) processes the trigger data and extracts the `trigger_id` and `data`.
- The `run` function in [`/components/eth-price-oracle/src/lib.rs`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/components/eth-price-oracle/src/lib.rs#L13) calls `decode_trigger_event`, processes the extracted trigger data, and determines how to handle it.
- When testing, the `wasi-exec` command in the [`Makefile`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/Makefile#L39-L43) passes input data when testing WAVS components via ``--input `cast format-bytes32-string $(COIN_MARKET_CAP_ID)` ``. This uses cast to format the `COIN_MARKET_CAP_ID` as a bytes32 string and simulates an Ethereum event during local execution.


## Trigger configuration

Triggers define when and how the component should be executed. Each workflow needs a trigger to be set. They are set in the `trigger` field of the `service.json` file.

### EVM event trigger

This trigger listens for specific events emitted by contracts on EVM-compatible chains, executing the component when a matching event is detected.

```json

  "trigger": {
    "evm_contract_event": {
      "address": "0x00000000219ab540356cbb839cbe05303d7705fa", // Contract address to monitor
      "chain_name": "ethereum-mainnet", // Chain to monitor
      "event_hash": "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef" // Event hash (32 bytes)
    }
  },

```

Your evm chain information must be set in `wavs.toml` under the `[default.chains.evm.<chain_name>]` section:

```toml wavs.toml
# Local / Testnet
[default.chains.evm.local]
chain_id = "31337"
ws_endpoint = "ws://localhost:8545"
http_endpoint = "http://localhost:8545"
poll_interval_ms = 7000
```

Your EVM chain credential must be set in your `.env` file:

```env .env
WAVS_CLI_EVM_CREDENTIAL="0x5ce146f435835b1762ed602088740d201b68fd94bf808f97fd04588f1a63c9ab"
```

### Cosmos event trigger

This trigger monitors events emitted by Cosmos smart contracts, executing your component when a matching event type is detected from the specified contract address.

```json
  "trigger": {
    "cosmos_contract_event": {
      "address": {
        "Cosmos": {
          "bech32_addr": "neutron1qlaq54uh9f52d3p66q77s6kh9k9ee3vasy8gkdkk3yvgezcs6zts0mkcv4", // Contract address to monitor
          "prefix_len": 7 // Length of the Bech32 prefix (7 for Neutron)
        }
      },
      "chain_name": "neutron", // Chain to monitor
      "event_type": "send_nft" // Event type to watch
    }
  },
```

Your chain information must be set in `wavs.toml` under the `[default.chains.cosmos.<chain_name>]` section:

```toml wavs.toml
# == Cosmos chains ==

[default.chains.cosmos.neutron]
chain_id = "pion-1"
bech32_prefix = "neutron"
rpc_endpoint = "https://rpc-falcron.pion-1.ntrn.tech"
grpc_endpoint = "http://grpc-falcron.pion-1.ntrn.tech:80"
gas_price = 0.0053
gas_denom = "untrn"
```

Your Cosmos mnemonic must be set in your `.env` file:

```env .env
WAVS_CLI_COSMOS_MNEMONIC="large slab plate twenty laundry illegal vacuum phone drum example topic reason"
```

### Cron trigger

Executes your component on a schedule defined by a cron expression, with optional start and end times to control the execution window. If no start or end time is provided, the component will start immediately and run indefinitely.

```json

  "trigger": {
    "cron": {
      "schedule": "0 */5 * * * *",  // Every 5 minutes (at 0 seconds)
      "start_time": 1704067200000000000,  // Optional start time in nanoseconds since Unix epoch (2024-01-01T00:00:00Z) (default: null)
      "end_time": 1735689599000000000     // Optional end time in nanoseconds since Unix epoch (default: null)
    }
  }

// Cron Expression Format:
// * * * * * *
// │ │ │ │ │ │
// │ │ │ │ │ └── Day of week (0-6, where 0 is Sunday)
// │ │ │ │ └──── Month (1-12)
// │ │ │ └────── Day of month (1-31)
// │ │ └──────── Hour (0-23)
// │ └────────── Minute (0-59)
// └──────────── Second (0-59)
//
// Each field can be:
// - A number:    `5`      (exact time)
// - A range:     `1-5`    (1 through 5)
// - A list:      `1,3,5`  (1, 3, and 5)
// - A step:      `*/5`    (every 5 units)
// - An asterisk: `*`      (every unit)
//
// Common examples:
// - `0 */5 * * * *`     - Every 5 minutes (at 0 seconds)
// - `0 0 */6 * * *`     - Every 6 hours (at 0 minutes and 0 seconds)
// - `0 0 0 * * *`       - Every day at midnight (00:00:00)
// - `0 0 12 * * *`      - Every day at noon (12:00:00)
// - `0 0 12 1 * *`      - Noon on the first day of every month
// - `0 0 12 * * 1`      - Noon every Monday
```

[Crontab.guru](https://crontab.guru/) is a helpful tool for making cron expressions.

<Callout title="Cron trigger latency" type="info">

There may be slight variations in Cron trigger execution time between operators due to network latency and clock drift. Cron triggers are best suited for tasks that don't require precise synchronization between operators:
- Triggering components that don't need exact synchronization.
- Collecting data from external services with monotonic pagination.
- Background tasks where eventual consistency is acceptable.

If you need precise timing synchronization between operators, consider using [block-based triggers](#block-trigger) instead.

</Callout>

### Block trigger

Executes your component at regular block intervals on a specified EVM or Cosmos chain, useful for chain-specific operations that need to run periodically.

```json
  "trigger": {
    "block_interval": {
      "ethereum-mainnet": "layer-hacknet", // Chain to monitor
      "n_blocks": 10 // Number of blocks between triggers
    }
  },
```

{/* todo: update this info when https://github.com/Lay3rLabs/WAVS/issues/612 is resolved */}

The `chain-name` in your block trigger configuration is set in `wavs.toml` under the `[default.chains.evm.<chain_name>]` or `[default.chains.cosmos.<chain_name>]` section. It also needs to be added to the `active_trigger_chains` list in `wavs.toml`.

```toml
[wavs]
active_trigger_chains = ["<chain_name>"]
```

