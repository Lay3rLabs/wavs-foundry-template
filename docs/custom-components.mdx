---
title: Customize the template
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

Use the info in this guide to customize the template to create your own custom service.

Check out the [WAVS design considerations](/design) page to learn which use-cases WAVS is best suited for.

## Trigger

The simple onchain trigger contract in the template is used to emit triggers to the WAVS service. The trigger data is encoded as a bytes object. When a WAVS component receives this trigger, it uses the `decode_event_log_data!` macro from the [`wavs-wasi-chain`](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions) crate to decode the event data for processing.

The trigger in the template is a simple example that takes generic bytes and passes them to the component. When developing a custom trigger, you will need to update the template code in a few places:

1. The trigger contract itself in [`src/WavsTrigger.sol`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/src/contracts/WavsTrigger.sol), which defines how triggers are created and emitted on-chain.
2. The trigger script in [`/script/Trigger.s.sol`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/script/Trigger.s.sol#L15), which calls the `addTrigger` function with the `coinMarketCapID`.
3. The `decode_trigger_event` function in [`/components/eth-price-oracle/src/trigger.rs`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/components/eth-price-oracle/src/trigger.rs#L11-L21), which processes the trigger data and extracts the `trigger_id` and `data`.
4. The `run` function in [`/components/eth-price-oracle/src/lib.rs`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/components/eth-price-oracle/src/lib.rs#L13), which calls `decode_trigger_event`, processes the extracted trigger data, and determines how to handle it.
5. The `wasi-exec` command in the [`Makefile`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/Makefile#L39-L43), which passes input data when testing WAVS components via `--input cast format-bytes32-string $(COIN_MARKET_CAP_ID)`. This simulates an Ethereum event during local execution.

## Component

The component is the main logic of the WAVS component. It is responsible for processing the trigger data and determining how to handle it.

A basic component has three main parts:

1. Decoding trigger data
2. Processing the data (this is the custom logic of your component)
3. Encode and returning the result for submission.

```rust
impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<Vec<u8>>, String> {
        // 1. Decode the trigger data
        let (trigger_id, req, dest) = decode_trigger_event(action.data)?;
        
        // 2. Process the data (Your custom logic here)
        let result = process_data(req)?;
        
        // 3. Encode and return the result
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &result)),
            Destination::CliOutput => Some(result),
        };
        Ok(output)
    }
}
```


Bindings are automatically generated for any files in the `/components` and `/src` directories when the `make build` command is run.

### HTTP requests

### Dependencies

The following dependencies are useful for making HTTP requests from a component. Make sure to add them to your `Cargo.toml` file:

```toml
[dependencies]
wavs-wasi-chain = { workspace = true }  # HTTP utilities
wstd = { workspace = true }             # Runtime utilities
serde = { workspace = true }            # Serialization
serde_json = { workspace = true }       # JSON handling
```

The `wavs-wasi-chain` crate provides a set of helpful functions for making HTTP requests. It also provides a macro for decoding trigger data for use in the component.

Learn more in the [crate documentation](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions).


The following example shows how to make a basic HTTP GET request from a component:


```rust
async fn make_request() -> Result<YourResponseType, String> {
    // Create the request
    let url = "https://api.example.com/endpoint";
    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    
    // Add headers
    req.headers_mut().insert(
        "Accept", 
        HeaderValue::from_static("application/json")
    );
    
    // Make the request and parse JSON response
    let json: YourResponseType = fetch_json(req)
        .await
        .map_err(|e| e.to_string())?;
        
    Ok(json)
}
```

Use https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions 



##  Contract interfaces

You can view the code for the Solidity interfaces on the WAVS NPM package site: https://www.npmjs.com/package/@wavs/solidity?activeTab=code

## kv storage
