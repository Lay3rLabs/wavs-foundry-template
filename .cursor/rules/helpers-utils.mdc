---
description: 
globs: 
alwaysApply: false
---
---
description: Guide to WAVS helper utilities and tools
globs: components/**/*.rs
alwaysApply: true
---
# Helpers and Utilities

WAVS provides several helper utilities and tools to simplify development. This guide covers the most commonly used ones.

## sol! Macro

The `sol!` macro from `alloy-sol-macro` allows you to generate Rust types from Solidity interface files.

### Dependencies
```toml
[dependencies]
alloy-sol-macro = { workspace = true }  # For Solidity type generation
alloy-sol-types = { workspace = true }  # For ABI handling
```

### Usage Examples

#### From Interface File
```rust
mod solidity {
    use alloy_sol_macro::sol;
    sol!("../../src/interfaces/ITypes.sol");
}
```

#### Inline Definition
```rust
sol! {
    struct TriggerInfo {
        uint64 triggerId;
        bytes data;
    }
    
    event NewTrigger(TriggerInfo _triggerInfo);
}
```

## wavs-wasi-chain Crate

The `wavs-wasi-chain` crate provides essential functions for WAVS development.

### HTTP Utilities
```rust
use wavs_wasi_chain::http::{http_request_get, http_request_post_json, fetch_json};

// GET request
let mut req = http_request_get(&url)?;

// POST request with JSON
let response = fetch_json(http_request_post_json(&url, &data)?)?;
```

### Ethereum Utilities
```rust
use wavs_wasi_chain::ethereum::new_eth_provider;
use wavs_wasi_chain::decode_event_log_data;

// Create provider
let provider = new_eth_provider::<Ethereum>(endpoint)?;

// Decode event data
let event = decode_event_log_data!(log)?;
```

## wstd Crate

The `wstd` crate provides runtime utilities for WASI components.

### Async Support
```rust
use wstd::runtime::block_on;

fn sync_function() -> Result<(), String> {
    block_on(async move {
        // Async code here
        Ok(())
    })?
}
```

## Best Practices

1. Use `sol!` for all Solidity type definitions
2. Leverage helper functions from `wavs-wasi-chain`
3. Use `block_on` for async operations
4. Implement proper error handling
5. Document complex type definitions
6. Test generated types thoroughly
7. Keep utility functions focused
8. Use appropriate logging
9. Consider performance implications
10. Follow Rust best practices