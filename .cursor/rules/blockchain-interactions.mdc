---
description: 
globs: 
alwaysApply: false
---
---
description: Guidelines for blockchain interactions in WAVS components
globs: components/**/*.rs
alwaysApply: true
---
# Blockchain Interactions

WAVS components can interact with blockchains like Ethereum. This guide covers how to set up and use blockchain interactions in components.

## Dependencies

Add these dependencies to your component's `Cargo.toml`:

```toml
[dependencies]
# Core WAVS blockchain functionality
wavs-wasi-chain = { workspace = true }

# Alloy crates for Ethereum interaction
alloy-sol-types = { workspace = true }  # ABI handling & type generation
alloy-sol-macro = { workspace = true }  # sol! macro for interfaces
alloy-primitives = { workspace = true } # Core primitive types
alloy-network = "0.11.1"               # Network trait
alloy-provider = { version = "0.11.1", default-features = false, features = ["rpc-api"] }
alloy-rpc-types = "0.11.1"            # RPC type definitions

# Other useful crates
anyhow = { workspace = true }          # Error handling
serde = { workspace = true }           # Serialization
serde_json = { workspace = true }      # JSON handling
```

## Chain Configuration

Configure chains in `wavs.toml`:

```toml
[chains.eth.local]
chain_id = "31337"
ws_endpoint = "ws://localhost:8545"
http_endpoint = "http://localhost:8545"

[chains.eth.mainnet]
chain_id = "1"
ws_endpoint = "wss://mainnet.infura.io/ws/v3/YOUR_INFURA_ID"
http_endpoint = "https://mainnet.infura.io/v3/YOUR_INFURA_ID"
```

## Example: Querying NFT Balance

```rust
use crate::bindings::host::get_eth_chain_config;
use alloy_network::{Ethereum, Network};
use alloy_primitives::{Address, Bytes, TxKind, U256};
use alloy_provider::{Provider, RootProvider};
use alloy_rpc_types::{TransactionInput, eth::TransactionRequest};
use alloy_sol_types::{sol, SolCall};
use wavs_wasi_chain::ethereum::new_eth_provider;
use anyhow::Context;
use wstd::runtime::block_on;

// Define the ERC721 interface
sol! {
    interface IERC721 {
        function balanceOf(address owner) external view returns (uint256);
    }
}

async fn query_nft_ownership(owner_address: Address, nft_contract: Address) -> Result<bool, String> {
    // 1. Get chain configuration
    let chain_config = get_eth_chain_config("eth.local")
        .map_err(|e| format!("Failed to get eth.local chain config: {}", e))?;

    // 2. Create Ethereum provider
    let provider: RootProvider<Ethereum> = new_eth_provider::<Ethereum>(
        chain_config.http_endpoint
            .context("http_endpoint missing for eth.local")?
    ).map_err(|e| format!("Failed to create provider: {}", e))?;

    // 3. Prepare contract call
    let balance_call = IERC721::balanceOfCall { owner: owner_address };

    // 4. Construct transaction request
    let tx = TransactionRequest {
        to: Some(TxKind::Call(nft_contract)),
        input: TransactionInput {
            input: Some(balance_call.abi_encode().into()),
            data: None
        },
        ..Default::default()
    };

    // 5. Execute call
    let result_bytes = provider.call(&tx)
        .await
        .map_err(|e| format!("Provider call failed: {}", e))?;

    // 6. Decode result
    if result_bytes.len() != 32 {
        return Err(format!("Unexpected result length: {}", result_bytes.len()));
    }
    let balance = U256::from_be_slice(&result_bytes);

    // 7. Return ownership status
    Ok(balance > U256::ZERO)
}

fn main_logic(owner: Address, contract: Address) -> Result<bool, String> {
    block_on(async move {
        query_nft_ownership(owner, contract).await
    })?
}
```

## Best Practices

1. Use appropriate error handling
2. Validate chain configurations
3. Use proper type definitions
4. Handle network errors gracefully
5. Implement retry logic
6. Use appropriate gas limits
7. Validate contract addresses
8. Document contract interfaces
9. Test with local networks first
10. Consider gas optimization