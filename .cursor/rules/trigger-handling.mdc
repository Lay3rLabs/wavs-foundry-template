---
description: 
globs: 
alwaysApply: false
---
---
description: Guidelines for handling triggers in WAVS components
globs: components/**/trigger.rs
alwaysApply: true
---
# Trigger Handling

Triggers are events that prompt a WAVS service to run. This guide covers how to handle triggers in your components.

## Trigger Lifecycle

1. Service deployment configures trigger address and event
2. Operators listen to chain logs for trigger events
3. When triggered, WAVS creates a `TriggerAction` with event data
4. Component processes the trigger data

## Trigger Data Structure

```rust
TriggerAction {
    config: TriggerConfig {
        service_id: ServiceID,
        workflow_id: WorkflowID,
        trigger: Trigger::EthContractEvent {
            address: Address,
            chain_name: ChainName,
            event_hash: ByteArray<32>
        }
    },
    data: TriggerData::EthContractEvent {
        contract_address: Address,
        chain_name: ChainName,
        log: LogData {
            topics: Vec<Vec<u8>>,
            data: Vec<u8>
        },
        block_height: u64
    }
}
```

## Implementation

### 1. Define Solidity Types

```rust
mod solidity {
    use alloy_sol_macro::sol;
    sol!("../../src/interfaces/ITypes.sol");
}
```

### 2. Decode Trigger Data

```rust
use wavs_wasi_chain::decode_event_log_data;

fn decode_trigger_event(log: &LogData) -> Result<(u64, Vec<u8>), String> {
    let event = decode_event_log_data!(log)?;
    Ok((event.triggerId, event.data))
}
```

### 3. Handle Different Trigger Types

```rust
impl Guest for Component {
    fn run(action: TriggerAction) -> Result<Option<Vec<u8>>, String> {
        match action.data {
            // On-chain event handling
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {
                let (trigger_id, data) = decode_trigger_event(&log)?;
                // Process data
                Ok(Some(result.abi_encode()))
            }
            // Manual trigger handling for testing
            TriggerData::Raw(data) => {
                // Process raw data directly
                Ok(Some(result))
            }
            _ => Err("Unsupported trigger type".to_string())
        }
    }
}
```

## Best Practices

1. Use the `sol!` macro for Solidity type definitions
2. Implement proper error handling
3. Support both on-chain and manual triggers
4. Use appropriate logging for debugging
5. Validate trigger data before processing
6. Keep trigger handling logic separate from business logic
7. Document trigger event signatures
8. Test trigger handling with both real and simulated events