---
description: Guidelines for handling input data in WAVS components
globs: components/**/*.rs
alwaysApply: true
---
# Input Handling Guidelines

Guidelines for handling input data in WAVS components:

1. Input Mechanism:
```rust
// The make command converts COIN_MARKET_CAP_ID to hex string
// Example: COIN_MARKET_CAP_ID=5 becomes "5" as hex string
// Example: COIN_MARKET_CAP_ID=a becomes "a" as hex string
fn run(action: TriggerAction) -> Result<Option<Vec<u8>>, String> {
    let (trigger_id, req, dest) = decode_trigger_event(action.data)?;
    
    // Convert bytes to string
    let input = std::str::from_utf8(&req)?;
    
    // Parse first character as hex digit
    let number = input.chars().next()
        .ok_or("Empty input")?
        .to_digit(16)
        .ok_or("Invalid hex digit")? as u64;
        
    // Process the number
    let result = process_number(number);
    
    // Return result
    Ok(Some(result.to_string().into_bytes()))
}
```

2. Common Input Patterns:
```rust
// Pattern 1: Single hex digit input
let number = input.chars().next()
    .ok_or("Empty input")?
    .to_digit(16)
    .ok_or("Invalid hex digit")? as u64;

// Pattern 2: Multiple hex digits
let number = u64::from_str_radix(input, 16)
    .map_err(|e| format!("Invalid hex number: {}", e))?;

// Pattern 3: Raw bytes
let data = req.to_vec();

// Pattern 4: JSON input
let json: YourType = serde_json::from_slice(&req)
    .map_err(|e| format!("Invalid JSON: {}", e))?;
```

3. Best Practices:
- Always validate input format before processing
- Handle empty or malformed input gracefully
- Use appropriate error messages
- Consider input size limits
- Log input for debugging
- Handle both hex and decimal inputs if needed

4. Testing Input:
```bash
# Test with single hex digit
COIN_MARKET_CAP_ID=5 make wasi-exec  # Input: "5" (hex)
COIN_MARKET_CAP_ID=a make wasi-exec  # Input: "a" (hex = 10 decimal)
COIN_MARKET_CAP_ID=f make wasi-exec  # Input: "f" (hex = 15 decimal)

# Test with custom component
COMPONENT_FILENAME=your_component.wasm COIN_MARKET_CAP_ID=5 make wasi-exec
```

5. Common Pitfalls:
```rust
// BAD: Trying to parse entire input as decimal
let number = input.parse::<u64>()?;  // Will fail for hex input

// BAD: Not handling empty input
let number = input.chars().next().unwrap().to_digit(16).unwrap() as u64;

// GOOD: Proper error handling
let number = input.chars().next()
    .ok_or("Empty input")?
    .to_digit(16)
    .ok_or("Invalid hex digit")? as u64;
```

6. Input Validation:
```rust
fn validate_input(input: &str) -> Result<u64, String> {
    // Check input length
    if input.is_empty() {
        return Err("Empty input".to_string());
    }
    
    // Check for valid hex characters
    if !input.chars().all(|c| c.is_ascii_hexdigit()) {
        return Err("Invalid hex characters".to_string());
    }
    
    // Parse hex
    u64::from_str_radix(input, 16)
        .map_err(|e| format!("Invalid hex number: {}", e))
}
```

7. Logging Input:
```rust
// Log input for debugging
println!("Received input: {}", input);

// Log parsed value
println!("Parsed number: {}", number);

// Log result
println!("Processing result: {}", result);
```

8. Error Handling:
```rust
// Use descriptive error messages
.map_err(|e| format!("Failed to process input: {}", e))?;

// Handle specific error cases
match parse_input(input) {
    Ok(number) => process_number(number),
    Err(e) => {
        println!("Input error: {}", e);
        return Err(e);
    }
}
```

9. Security Considerations:
- Validate input size
- Check for malicious input
- Don't expose sensitive data in logs
- Handle overflow cases
- Sanitize input before processing

10. Example Component:
```rust
fn run(action: TriggerAction) -> Result<Option<Vec<u8>>, String> {
    // Decode trigger event
    let (trigger_id, req, dest) = decode_trigger_event(action.data)?;
    
    // Convert to string and log
    let input = std::str::from_utf8(&req)?;
    println!("Received input: {}", input);
    
    // Parse hex input
    let number = input.chars().next()
        .ok_or("Empty input")?
        .to_digit(16)
        .ok_or("Invalid hex digit")? as u64;
    
    println!("Parsed number: {}", number);
    
    // Process input
    let result = process_input(number);
    
    // Format output
    let output = result.to_string().into_bytes();
    
    // Return based on destination
    Ok(Some(match dest {
        Destination::Ethereum => encode_trigger_output(trigger_id, &output),
        Destination::CliOutput => output,
    }))
}
``` 
