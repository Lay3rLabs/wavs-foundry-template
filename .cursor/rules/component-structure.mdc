---
description: 
globs: 
alwaysApply: false
---
---
description: Guidelines for WAVS component structure and organization
globs: components/**/*
alwaysApply: true
---
# Component Structure

WAVS components are Rust-based WASI modules that form the core business logic of a service. Each component should follow a consistent structure and organization pattern.

## Directory Structure

```
components/
└── your-component/
    ├── Cargo.toml     # Component dependencies
    ├── lib.rs         # Main Component logic
    ├── trigger.rs     # Trigger handling
    └── bindings.rs    # Bindings generated by `make build`
```

## Core Files

### Cargo.toml
- Contains component dependencies and metadata
- Required dependencies:
  ```toml
  [dependencies]
  wit-bindgen-rt = {workspace = true}    # Required for WASI bindings and Guest trait
  wavs-wasi-chain = { workspace = true }  # Required for core WAVS functionality
  ```

### lib.rs
- Main entry point for component logic
- Must implement the `Guest` trait
- Contains the `run` function that processes triggers
- Example structure:
  ```rust
  #[allow(warnings)]
  mod bindings;
  use bindings::{export, Guest, TriggerAction};
  
  struct Component;
  export!(Component with_types_in bindings);
  
  impl Guest for Component {
      fn run(action: TriggerAction) -> Result<Option<Vec<u8>>, String> {
          // Component logic here
      }
  }
  ```

### trigger.rs
- Handles trigger data decoding and processing
- Uses `sol!` macro for Solidity type definitions
- Example structure:
  ```rust
  mod solidity {
      use alloy_sol_macro::sol;
      sol!("../../src/interfaces/ITypes.sol");
  }
  ```

### bindings.rs
- Automatically generated by `make build`
- Contains WASI bindings and type definitions
- Should not be edited manually

## Best Practices

1. Keep components focused on a single responsibility
2. Use clear, descriptive names for components and functions
3. Implement proper error handling
4. Use the `sol!` macro for Solidity type definitions
5. Follow Rust best practices for code organization
6. Document public interfaces and complex logic
7. Use environment variables for configuration
8. Implement proper logging for debugging